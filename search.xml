<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tail-Call-Optimization]]></title>
    <url>%2F2019%2F09%2F29%2Ftail-call-optimization%2F</url>
    <content type="text"><![CDATA[什么是尾调用？简单的说，尾调用就是一个出现在另一个函数‘结尾’处的函数调用，这个调用结束后就没有其他事情可做了（除了可能要返回结果值）。 举个例子以下是一个非递归的尾调用：123456789function foo(x) &#123; return x&#125;function bar(y) &#123; return foo(y + 1) // 尾调用&#125;function baz() &#123; return 1 + bar(40) // 非尾调用&#125; 在上面的例子中，foo(y + 1)是bar()的尾调用，因为在foo()完成后bar()也完成了。 不深入细节的话，调用一个新的函数需要额外的一块预留内存来管理调用栈，称之为栈帧。所以前面的代码会同时为baz()、 bar()、 foo()保留一个栈帧。 然而，如果支持TCO的引擎能够意识到foo(y + 1)调用位于尾部，这意味着bar()已经完成，那么在调用foo()时，就不需要创建一个新的栈帧，而是可以重用已有的bar()的栈帧。好处是不仅速度更快，也更加节省内存。 在简单的代码片段里，这类优化算不上什么，但是在处理递归时（因为递归可能会生成成百上千的栈帧），就解决了大问题。有了TCO，引擎可以用同一个栈帧执行所有这类调用。 TCO优化下面是一个经典的阶乘算法：1234function factorial(n) &#123; if(n &lt; 2) return 1; return n * factorial(n - 1);&#125; 虽然能够解决问题，但它不是尾调用，我们可以进行优化：1234567function factorial(n) &#123; function fact(n, res) &#123; if (n &lt; 2) return res; return fact(n - 1, n * res); &#125; return fact(n, 1);&#125; 改进后的算法是可以TCO优化的，因为内部的两次fact()调用都是在结尾处。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Golang学习笔记]]></title>
    <url>%2F2019%2F09%2F25%2Fgo-notes%2F</url>
    <content type="text"><![CDATA[强制类型转换 go没有隐式类型转换，比如float64不能赋值给int类型的变量必须包一层：int（float64） 常量const及枚举 go中常量一般不用大写 枚举： 普通枚举和自增型枚举（实际就是const） 12345678910//自增枚举，利用iotafunc main() &#123; const ( a = iota _ c d ) fmt.Println(a, d, c) // 0,3,2&#125; 条件语句 if条件语句不需要 () if条件语句可以赋值 if条件里赋值的变量作用域就在这个if语句里面，外部无法访问 switch不需调用break switch可以不写判断条件，直接放在case里判断 12345if contents, err := ioutil.ReadFile(abc.txt); err == nil &#123; //拿到contents&#125;else &#123; //err&#125; 可变参数1234func rangeArgs(args ...int) int &#123; //··· return ···&#125; 数组 值类型（例如：将数组作为参数传递的时候会拷贝一份数组，而不会改变原来的数组） go的参数传递都是值传递，都会拷贝(大多数语言都是引用传递，即会改变原来的值) 思考：既然go都是值传递，都会拷贝，那么会有性能影响吗？这就涉及到与指针配合 go中不直接用数组，而是切片 数组定义1234567var arr [5]int // 长度为5，值为int的数组arr := [5]int&#123;1,2,3,4,5&#125; // 不用var关键字时需要指明具体项arr := [...]int&#123;1,2,3&#125; // ...表示让编译器帮我们计算数组长度var grid [4][5]int // 4行5列二维的数组 数组遍历12345678910111213// 常规forfor i := 0; i &lt; len(arr); i++ &#123; fmt.PrintIn(arr[i])&#125;// 一般用range 关键字// 例子：找出数组最大值及其下标maxIndex := -1maxValue := -1for i, v := range arr &#123; if v &gt; maxValue &#123; maxIndex, maxValue = i, v &#125;&#125; 指针前面说过go的参数都是值传递，也就是会拷贝一份，现在如果我们要交换两个变量的值怎么做？123456789//这么做是不行的，因为swap()拷贝了a,b、并不影响原来的a,bfunc main() &#123; a, b int := 1, 2 swap(a, b) fmt.PrintIn(a, b) // 1, 2&#125;func swap(a, b) &#123; a, b = b, a&#125; 123456789//不直接传递a,b、而是传递a,b的指针，指针的修改改变了原来的a,bfunc main() &#123; a, b int := 1, 2 swap(&amp;a, &amp;b) fmt.PrintIn(a,b)&#125;func swap(a, b *int) &#123; *a, *b = *b, *a&#125; 123456789//直接返回两个值func main() &#123; a, b int := 1, 2 a, b = swap(a,b) fmt.PrintIn(a,b)&#125;func swap(a, b int) (int int) &#123; return b, a&#125; 切片 前面说过，一般不直接操作数组，而使用切片 slice切片是对数组的一个view（也仅仅是一个view而已，没有改变原数组），它不是值类型，对切片的修改会影响原数组 比如我们要在一个函数体里面修改外部的一个数组，有两种方法：指针或切片 通过指针修改12345678func main() &#123; arr := [...]int&#123;0,1,2,3,4&#125; update(&amp;arr) fmt.Println(arr) //[100,1,2,3,4]&#125;func update(arr *[5]int) &#123; arr[0] = 100&#125; 通过切片修改123456789func main() &#123; arr := [...]int&#123;0,1,2,3,4&#125; update(arr[:]) //这里传递的是切片 fmt.Println(arr) //[100,1,2,3,4]&#125;//[]int表示切片func update(arr []int) &#123; arr[0] = 100&#125; 切片的append 向切片新增成员如果超过了底层数组的cap(),那么go会自动分配一个更大的底层数组，原来的底层数组如果不再使用的话会被GC掉； 1234567891011func main() &#123; arr := [...]int&#123;0,1,2,3,4,5&#125; s1 := arr[1,4] //[1,2,3] s2 := s1[2,4] //[3,4] //这里s3仍然是arr的view，因为没有超过cap() s3 := append(s2, 10) //[3,4,10] //这里s4不再是arr的view，而是新的更大底层数组的view s4 := append(s3, 11) //[3,4,10,11] //arr最后是：[0,1,2,3,4,10]&#125; 切片的定义、拷贝、删除12345678//定义一个空的slices := []int // nil//定义一个len为10的slices := make([]int, 10)//定义一个len=10，cap=32的slices := make([]int, 10, 32) 1234567s1 := []int&#123;1,2,3,4,5&#125;s2 := make([]int, 10, 16)//拷贝：s2是destination，s1是sourcecopy(s2, s1) //s2: [1,2,3,4,5,0,0,0,0,0] len=10 cap=16//delete 5s2 = append(s2[:4], s2[5:]...) // s2: [1,2,3,4,0,0,0,0,0] len=9 cap=16 map slice、map、function不能作为map的key 12345678//创建mapm := map[string]string &#123; "name": "tian"&#125;m := make(map[string]bool) // empty mapvar m map[string]bool // nil 123456789101112131415161718//取map的值//注意：//**取不存在的key不会报undefined，而是得到一个empty value**m := map[string]string &#123; "name": "tian", "age": "20"&#125;v := m['namesss'] // ''//那么如何判断是否存在这个key呢？v, ok := m['name'] // tian truev, ok := m['namesss'] // '' falseif v, ok := m['namesss']; ok &#123; //存在这个key&#125;else &#123; //不存在这个key&#125; 12//删除keydelete(m, 'name') 1234// map的key是无序的，如需拿到对应顺序的key，需要借助slice（它是有序的）for k, v := range m &#123; // k, v&#125; map的key类型 map使用hash表，必须可以比较相等 除了slice,map,function的内建类型都可以作为map的key Struct类型不包括slice,map,function，也可以作为map的key 算法例题1234567891011121314151617181920212223//寻找最长不包含重复字符的子串func lengOfNonRepeatSting(s string) int &#123; lastOccurred := make(map[rune]int) start := 0 maxLength := 0 for i, char := range []rune(s) &#123; lastIndex, ok := lastOccurred[char] if ok &amp;&amp; lastIndex &gt;= start &#123; start = lastIndex + 1 &#125; if i-start+1 &gt; maxLength &#123; maxLength = i - start + 1 &#125; lastOccurred[char] = i &#125; return maxLength&#125;func main() &#123; fmt.Println( lengOfNonRepeatSting("我爱你"))&#125; 面向对象 go只有封装(struct)，没有继承和多态 1234type treeNode struct &#123; value int left, right *treeNode&#125; 123456789101112131415161718//工厂函数func createNode(value int) *treeNode &#123; return &amp;treeNode&#123;value: value&#125;&#125;func main() &#123; //定义一个空的treeNode var root = treeNode //or root := treeNode&#123;&#125; //为这个空的treeNode赋值 root.value = 1 root.right = &amp;treeNode&#123;3, nil, nil&#125; root.left.right = new(treeNode) //作用和 treeNode&#123;&#125; 一样，new内建函数返回treeNode的地址 root.right.left = createNode(4) fmt.Println(root) //&#123;1 addr addr&#125; &#125; 1234567891011121314151617//为struct定义方法//这种写法实际上相当于把参数提到了前面，等同于this//好处是在不改变方法调用的情况下能够实现 引用传递//如果是普通的写法，在调用时需要显式地传一个&amp;func (node treeNode) print() &#123; fmt.Println(node.value)&#125;//这个方法通过指定node的类型（treeNode or *treeNode）来判断是 值传递（拷贝一份不改变原值） or 引用传递（传递地址改变原值）func (node *treeNode) setValue(value int) &#123; node.value = value&#125;func main() &#123; var root treeNode root.left = &amp;treeNode&#123;1, nil, nil&#125; root.left.setValue(2) root.print() //2&#125; 1234567//结构也可以切片nodes := []treeNode &#123; &#123;value:3&#125;, &#123;&#125;, &#123;5,nil,&amp;root&#125;,&#125;fmt.Println(nodes) //[&#123;3 &lt;nil&gt; &lt;nil&gt;&#125; &#123;0 &lt;nil&gt; &lt;nil&gt;&#125; &#123;5 &lt;nil&gt; 0xc00000a080&#125;] 包为struct定义的方法必须在同一个包内，但如果我们想要扩展别人的包呢 扩充系统类型或者别人的类型 定义别名 使用组合 接口 由使用者定义接口的方法，实现者实现interface里定义的方法就行了 goroutinecoroutine协程 轻量级的线程 非抢占式多任务处理，由携程主动交出控制权 编译器、解释器、虚拟机层面的多任务（操作系统只有线程没有携程） goroutine goroutine相当于go编译器层面的协程 goroutine将go func转化为协程后由go的调度器处理 多个协程可以运行在一个或多个线程上（由go的调度器分配）]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Vue3.0浅谈前端框架的发展趋势]]></title>
    <url>%2F2019%2F09%2F01%2Fvue-3.0%2F</url>
    <content type="text"><![CDATA[3.0设计目标 更小 更快 加强TypeScript支持 加强API设计一致性 提高自身可维护性 开放更多底层功能 如何更快？Object.defineProperty -&gt; ProxyObject.defineProperty在改变对象属性这一操作上是相对昂贵的，因为js引擎在编译阶段是需要对代码做优化的，这个对象越稳定，可优化空间就越大。Object.defineProperty既然可以随意地修改对象属性，那么代码的可优化性将大大降低。而Proxy并不是简单地修改原来的对象，仅仅是在其之上做了一层代理：所有对该对象的访问和操作都需要通过这层proxy。因此，Proxy比Object.defineProperty性能更优。 当然，IE11仍然不支持Proxy，Vue的做法是在不支持Proxy的浏览器中降级使用Object.defineProperty，因此Vue3.0仍然支持IE，只是如果要兼容IE的话就无法享受新语法带来的好处了。 Virtual Dom 重构3.0的vdom使用了TypeScript进行重构，组件启动速度比2.x提高了接近一倍 编译时优化Slot默认编译为函数使得父子组件之间更新时不存在强耦合的关系 Monomorphic vnode factory重构生成vnode的工厂函数，使其函数参数更加一致化 Compiler-generated flags for vnode/children types编译时增加vnode及其children的类型信息 以上的编译时优化，可以让3.0的runtime变得更快 传统vdom的性能瓶颈以前我确实是对vdom存在一些误解，认为它能够提高应用的运行效率。然而实际上却非如此，它是为了将开发者从手动操作dom中解放出来（并且它是平台无关的，可以让我们的应用跑在非浏览器端，比如：rn/weex/mpvue/nodejs等）。 vdom赋予了更强的表达力，但是换来的代价是性能问题，没错，vdom在大部分情况下让开发者在无需操作dom的同时给予了应用还不错的性能，但在一些对性能要求极高的场景，它会拖慢我们的应用，比如atom编辑器，由于使用了react重构后频频出现性能问题，如今已被彻底放弃。再比如vscode，它和atom一样也是基于electron的，但为了性能只能完全手动去操作dom，这样在特殊场景可以做到针对性地极致优化，这是虚拟dom做不到的。 为什么会这样呢，究其原因，就不得不提到diff了（关于diff有篇文章讲的很清楚：不可思议的 react diff）。在vue或react里面，尽管能够保证组件粒度的更新，但是在单个组件内部却依然要去遍历组件的整个vdom树。这样看来，组件粒度的更新仍然显得有些粗糙，举个例子（vue）:123456789&lt;template&gt; &lt;div id="content"&gt; &lt;p class="text"&gt;aha&lt;/p&gt; &lt;p class="text"&gt;aha&lt;/p&gt; &lt;p class="text"&gt;aha&lt;/p&gt; &lt;p class="text"&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p class="text"&gt;aha&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 在这个模版里，只有一处是动态可改变的，尽管diff只比较同级的节点，但如果还是去遍历整个模版对应的vdom树，那就是浪费的。 为什么vdom要用这种不高效的算法？那是因为vdom最初并不是从模版编译而来，而是jsx。而我们都知道jsx或者render function是完全动态的，这就导致在编译时可以用于优化的信息很少，比如上面模版对应的render function:1234567891011function render() &#123; const children = [] for (let i = 0; i &lt; 5; i++) &#123; children.push('p', &#123; class: 'text' &#125;, i === 3 ? this.msg : 'aha') &#125; return h('div', &#123; id: 'content' &#125;, children)&#125; 你很难像模版一样，在编译时去提取静态信息。 react的解决方案是time slicing时间分片: React 在渲染（render）的时候，不会阻塞现在的线程 如果你的设备足够快，你会感觉渲染是同步的 如果你设备非常慢，你会感觉还算是灵敏的 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来 简单来说就是我的应用在更新时可能会超过16ms，但是我每隔大约16ms都会去把控制权交给CPU而不会屏蔽用户的操作。对react而言，这算是不错解决方案。但是对于vue或者svelte而言，是有能力把runtime做的足够轻量的，只要更新做的足够快，那么就不需要时间分片了。 svelte近来出现的一个新的框架svelte，单就写法而言很像vue的template，但是我认为它的出现并不是为了跟三大框架抢市场，而是想在更加细分的领域杀出一条出路，那就是将complier做到极致：你只能使用模版。在 svelte里面，没有vdom，没有jsx等。它将模版直接编译成最终代码，在更新时效率极高。当然这是一把双刃剑，只能使用模版在某些场景显得不够灵活。而且对于相同的功能，编译出来的代码量大概是vue的5倍左右。 Function-based API3.0采用了一套基于函数式的api，来看一个简单的demo：123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;span&gt;count is &#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;span&gt;plusOne is &#123;&#123; plusOne &#125;&#125;&lt;/span&gt; &lt;button @click="increment"&gt;count++&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; value, computed, watch, onMounted &#125; from 'vue'export default &#123; setup() &#123; // reactive state const count = value(0) // computed state const plusOne = computed(() =&gt; count.value + 1) // method const increment = () =&gt; &#123; count.value++ &#125; // watch watch(() =&gt; count.value * 2, val =&gt; &#123; console.log(`count * 2 is $&#123;val&#125;`) &#125;) // lifecycle onMounted(() =&gt; &#123; console.log(`mounted`) &#125;) // expose bindings on render context return &#123; count, plusOne, increment &#125; &#125;&#125;&lt;/script&gt; 关于为什么采用函数式的api，主要有以下优点： 更好的Typescript类型推导支持Typescript对函数的参数和返回值的支持是非常完善的，你甚至不用去写类型声明就可以获得完善的类型推导。 更强的Tree-shaking能力看前面的demo可以发现，3.0的api都是从vue里import而来，而tree-shaking的前提就是es module，也就是说如果你不去用这些api，它们都不会被打进你的bundle里面，减小了bundle的体积。 更容易被压缩的代码如果你看过webpack或者rollup等打包工具压缩后的代码，你会发现函数里的变量会被替换为单个字符（类似a,b,c,_等），而对于对象而言，它的key一般是不能被压缩或者说压缩后不安全。 更灵活的逻辑复用能力3.0实现逻辑复用的方式是hooks，在说hooks之前先说说原有的逻辑复用方式的缺陷 Mixin的缺点在3.0之前，vue的逻辑复用主要就是mixins，以侦听鼠标位置为例：1234567891011121314151617181920const mousePosMixin = &#123; data() &#123; return &#123; x: 0, y: 0 &#125; &#125;, mounted() &#123; window.addEventListener('mousemove', this.update) &#125;, destroyed() &#123; window.removeEventListener('mousemove', this.update) &#125;, methods: &#123; update(e) &#123; this.x = e.pageX this.y = e.pageY &#125; &#125;&#125; 当mixins的数量逐渐增加，我们常常会有这样的疑惑： 命名空间冲突 模版数据来源不清晰 这时我们往往容易迷失在各个变量中，搞不清楚这个变量到底从何而来。 Higher-order Components的缺点高阶组件在react里面比较常用，在vue里面用的比较少：1234const Demo = withMousePosition(&#123; props: ['x', 'y'], template: `&lt;div&gt;Mouse position: x &#123;&#123;x&#125;&#125; / y &#123;&#123;y&#125;&#125;&lt;/div&gt;`&#125;) 作为Mixin的替代品，它并不能很好地解决问题却又带来了新的问题： props命名空间冲突 props来源不清晰 额外的组件实例性能消耗 是的，当高阶组件嵌套越多，性能消耗也就越多 Hooks的优点将前面侦听鼠标位置的demo用hooks重写：12345678910111213141516171819202122232425function useMouse() &#123; const x = value(0) const y = value(0) const update = e =&gt; &#123; x.value = e.pageX y.value = e.pageY &#125; onMounted(() =&gt; &#123; window.addEventListener('mousemove', update) &#125;) onUnmounted(() =&gt; &#123; window.removeEventListener('mousemove', update) &#125;) return &#123; x, y &#125;&#125;// in consuming componentconst Component = &#123; setup() &#123; const &#123; x, y &#125; = useMouse() const &#123; z &#125; = useOtherLogic() return &#123; x, y, z &#125; &#125;, template: `&lt;div&gt;&#123;&#123; x &#125;&#125; &#123;&#123; y &#125;&#125; &#123;&#123; z &#125;&#125;&lt;/div&gt;`&#125; 这样一来解决了之前所有方案的缺陷： 没有命名空间冲突：完全可以在解构使用时把x,y进行重命名 数据来源清晰：你很清楚x,y是从哪个hook而来 没有额外的组件性能消耗：用函数承载逻辑 乍一看与 React Hooks 很像，但是有两个区别： useMouse 函数内改变 x、y 后，不会重新触发 setup 执行 x y 拿到的都是 Wrapper 而不是原始值，且这个值会动态变化。 总结目前了解到的就是这么多，后续再更新]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[受不了了，我要手撕webpack]]></title>
    <url>%2F2019%2F08%2F30%2Feasy-pack%2F</url>
    <content type="text"><![CDATA[本文其实是一个标题党，由于我本身对webpack的掌握也有限，因此这篇文章的目的也仅仅是对webpack打包原理的初探，不涉及loader和plugin的相关知识。我从一个简单的打包示例说起。 打包示例为了演示打包的原理，简单提供了以下示例：1234src - a.js // 模块a,引用了模块b - b.js // 模块b - index.js // 打包的入口，引用了模块a 123// b.jsexport const b = 'webpack'; 1234567// a.jsimport &#123; b &#125; from './b.js'const a = `Hello, $&#123;b&#125;`export default a 12345// index.jsimport a from './a.js'console.log(a) 打包原理webpack在打包时需要为其提供一个入口文件，然后根据这个入口文件去分析依赖，去区分不同的资源，并将不同资源交给对应的loader处理（参考：编写一个loader），在这个过程中webpack会广播许多事件, 可以在插件中监听这些事件来改变webpack的构建流程（参考：编写一个插件） 从入口分析想要实现一个打包工具，暂时抛开loader和plugin这些概念，先从入口文件着手分析。新建pack.js:123456789const fs = require('fs')const analyser = file =&gt; &#123; const content = fs.readFileSync(file, 'utf-8') console.log(content)&#125;analyser('./src/index.js') 执行node pack.js，控制台输出以下信息：123import a from './a.js'console.log(a) 可以发现入口文件依赖了a.js, 显然接下来要做的就是去获取a.js的内容，再去分析其依赖，一直到最底层的依赖为止，最终形成依赖树。 @babel/parser当然前面拿到的静态字符串没法很好地用来分析依赖，需要一个工具：@babel/parser，它用来将代码(js|jsx|flow|ts)转化成ast, 用法如下：12345678const analyser = file =&gt; &#123; const content = fs.readFileSync(file, 'utf-8') const ast = require('@babel/parser').parse(content, &#123; sourceType: 'module' &#125;) console.log(ast)&#125; 执行node pack.js，控制台输出以下信息：12345678910111213141516171819Node &#123; type: &apos;File&apos;, start: 0, end: 38, loc: SourceLocation &#123; start: Position &#123; line: 1, column: 0 &#125;, end: Position &#123; line: 3, column: 14 &#125; &#125;, program: Node &#123; type: &apos;Program&apos;, start: 0, end: 38, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, sourceType: &apos;module&apos;, interpreter: null, body: [ [Node], [Node] ], directives: [] &#125;, comments: [] &#125; 上面program表示当前运行的程序，其body下的两个节点，就是index.js对应的ast，打印出来看下： 12345678910111213141516171819202122232425262728# ast.program.body[ Node &#123; type: &apos;ImportDeclaration&apos;, start: 0, end: 22, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, specifiers: [ [Node] ], source: Node &#123; type: &apos;StringLiteral&apos;, start: 14, end: 22, loc: [SourceLocation], extra: [Object], value: &apos;./a.js&apos; &#125; &#125;, Node &#123; type: &apos;ExpressionStatement&apos;, start: 24, end: 38, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, expression: Node &#123; type: &apos;CallExpression&apos;, start: 24, end: 38, loc: [SourceLocation], callee: [Node], arguments: [Array] &#125; &#125; ] 没错，ImportDeclaration对应import a from &#39;./a.js&#39;，ExpressionStatement对应console.log(a)。接下来要做的就是遍历出这些依赖，也就是ImportDeclaration。 那怎么做呢？难道我们手动遍历吗？babel为我们提供了另外一个工具：@babel/traverse @babel/traverse它专门用于遍历ast，用法如下：1234567const traverse = require('@babel/traverse').defaulttraverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; console.log(node) &#125;&#125;) 其中的options传入ast里的type，并且是回调函数，意思是：遇到type为ImportDeclaration的节点就去执行这个函数，打印出来看下：1234567891011121314151617181920212223Node &#123; type: &apos;ImportDeclaration&apos;, start: 0, end: 22, loc: SourceLocation &#123; start: Position &#123; line: 1, column: 0 &#125;, end: Position &#123; line: 1, column: 22 &#125; &#125;, specifiers: [ Node &#123; type: &apos;ImportDefaultSpecifier&apos;, start: 7, end: 8, loc: [SourceLocation], local: [Node] &#125; ], source: Node &#123; type: &apos;StringLiteral&apos;, start: 14, end: 22, loc: SourceLocation &#123; start: [Position], end: [Position] &#125;, extra: &#123; rawValue: &apos;./a.js&apos;, raw: &apos;\&apos;./a.js\&apos;&apos; &#125;, value: &apos;./a.js&apos; &#125; &#125; 确实只有type: ImportDeclaration的节点，其下的source.value就是入口文件的依赖了，接下来我们将这些依赖以键为相对路径值为绝对路径，存在一个对象里面：12345678const dependencies = &#123;&#125;traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(file) // src dependencies[node.source.value] = './' + path.join(dirname, node.source.value) // ./src/a.js &#125;&#125;) 这时入口的的dependencies就是这样：1&#123; &apos;./a.js&apos;: &apos;./src/a.js&apos; &#125; 依赖关系确定好了，接下来将ast转化为浏览器端可以执行的代码，利用babel提供的@babel/core来做。 @babel/core 请先安装环境预设@babel/preset-env 它提供了许多方法，这里使用transformFromAst:123const &#123; code &#125; = babel.transformFromAst(ast, content, &#123; presets: ["@babel/preset-env"]&#125;) 打印code来看下：1234567"use strict";var _a = _interopRequireDefault(require("./a.js"));function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; "default": obj &#125;; &#125;console.log(_a["default"]); 最后在analyser函数的结尾，返回一个对象，到这里的完整代码如下：12345678910111213141516171819202122232425262728293031const fs = require('fs')const path = require('path')const babel = require('@babel/core')const traverse = require('@babel/traverse').defaultconst analyser = file =&gt; &#123; const content = fs.readFileSync(file, 'utf-8') const ast = require('@babel/parser').parse(content, &#123; sourceType: 'module' &#125;) const dependencies = &#123;&#125; traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(file) dependencies[node.source.value] = './' + path.join(dirname, node.source.value) &#125; &#125;) const &#123; code &#125; = babel.transformFromAst(ast, content, &#123; presets: ["@babel/preset-env"] &#125;) return &#123; file, dependencies, code &#125;&#125;const module = analyser('./src/index.js') 构建依赖树上面只是分析了入口文件，还需要递归拿到所有的依赖形成依赖树，代码如下：1234567891011121314151617181920212223242526const genDependenciesGraph = entry =&gt; &#123; const entryModule = analyser(entry) const graphArray = [ entryModule ] for(let i = 0; i &lt; graphArray.length; i++) &#123; const &#123; dependencies &#125; = graphArray[i] if(dependencies) &#123; for(let j in dependencies) &#123; graphArray.push(moduleAnalyser(dependencies[j])) &#125; &#125; &#125; const graph = &#123;&#125; graphArray.forEach(item =&gt; &#123; graph[item.file] = &#123; dependencies: item.dependencies, code: item.code &#125; &#125;) return graph&#125;const graph = genDependenciesGraph(&apos;./src/index.js&apos;) 最终看下拿到的依赖树graph:123456789101112&#123; &apos;./src/index.js&apos;: &#123; dependencies: &#123; &apos;./a.js&apos;: &apos;./src/a.js&apos; &#125;, code: &apos;&quot;use strict&quot;;\n\nvar _a = _interopRequireDefault(require(&quot;./a.js&quot;));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; &quot;default&quot;: obj &#125;; &#125;\n\nconsole.log(_a[&quot;default&quot;]);&apos; &#125;, &apos;./src/a.js&apos;: &#123; dependencies: &#123; &apos;./b.js&apos;: &apos;./src/b.js&apos; &#125;, code: &apos;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\n value: true\n&#125;);\nexports[&quot;default&quot;] = void 0;\n\nvar _b = require(&quot;./b.js&quot;);\n\nvar a = &quot;Hello, &quot;.concat(_b.b);\nvar _default = a;\nexports[&quot;default&quot;] = _default;&apos; &#125;, &apos;./src/b.js&apos;: &#123; dependencies: &#123;&#125;, code: &apos;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, &#123;\n value: true\n&#125;);\nexports.b = void 0;\nvar b = \&apos;hello\&apos;;\nexports.b = b;&apos; &#125; &#125; graph里的code目前是不能直接跑在浏览器的，因为浏览器里没有require函数和exports对象，后面在生成可执行代码时需要去手动构造这俩兄弟。 webpack打包后代码分析这里不妨先看下webpack`@4.39.3打包后的代码是什么样的，新建webpack.config.js`:12345678910const path = require('path')module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.join(__dirname, './dist'), filename: '[name].js' &#125;&#125; 终端执行npx webpack，在dist目录下生成main.js，看下打包内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);/******/ &#125;/******/ &#125;;/******//******/ // define __esModule on exports/******/ __webpack_require__.r = function(exports) &#123;/******/ if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123;/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;);/******/ &#125;/******/ Object.defineProperty(exports, '__esModule', &#123; value: true &#125;);/******/ &#125;;/******//******/ // create a fake namespace object/******/ // mode &amp; 1: value is a module id, require it/******/ // mode &amp; 2: merge all properties of value into the ns/******/ // mode &amp; 4: return value when already ns object/******/ // mode &amp; 8|1: behave like require/******/ __webpack_require__.t = function(value, mode) &#123;/******/ if(mode &amp; 1) value = __webpack_require__(value);/******/ if(mode &amp; 8) return value;/******/ if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;/******/ var ns = Object.create(null);/******/ __webpack_require__.r(ns);/******/ Object.defineProperty(ns, 'default', &#123; enumerable: true, value: value &#125;);/******/ if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));/******/ return ns;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module['default']; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, 'a', getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = "";/******//******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = "./src/index.js");/******/ &#125;)/************************************************************************//******/ (&#123;/***/ "./src/a.js":/*!******************!*\ !*** ./src/a.js ***! \******************//*! exports provided: default *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b.js */ \"./src/b.js\");\n\n\nconst a = `Hello, $&#123;_b_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"]&#125;`\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (a);\n\n//# sourceURL=webpack:///./src/a.js?");/***/ &#125;),/***/ "./src/b.js":/*!******************!*\ !*** ./src/b.js ***! \******************//*! exports provided: b *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() &#123; return b; &#125;);\nconst b = 'hello';\n\n//# sourceURL=webpack:///./src/b.js?");/***/ &#125;),/***/ "./src/index.js":/*!**********************!*\ !*** ./src/index.js ***! \**********************//*! no exports provided *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _a_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a.js */ \"./src/a.js\");\n\n\nconsole.log(_a_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n\n//# sourceURL=webpack:///./src/index.js?");/***/ &#125;)/******/ &#125;); 其实就是一个自执行函数：1234567891011121314151617181920212223242526(function(modules)&#123; // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // ... &#125; __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) &#123;&#125;; __webpack_require__.r = function(exports) &#123;&#125;; // ... return __webpack_require__(__webpack_require__.s = "./src/index.js"); &#125;)(&#123; "./src/a.js": (function(module, __webpack_exports__, __webpack_require__) &#123; eval(...) &#125;), "./src/b.js": (function(module, __webpack_exports__, __webpack_require__) &#123; eval(...) &#125;), "./src/index.js": (function(module, __webpack_exports__, __webpack_require__) &#123; eval(...) &#125;)&#125;) 看下__webpack_require__做了什么：1234567891011121314151617181920function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function // 这里的module.exports = &#123;&#125; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module // modules[moduleId].call的时候module.exports会被修改 return module.exports;&#125; 首先看这个模块是否注册过，如果有则直接返回这个模块 执行modules[moduleId].call()，这一步会修改module.exports 设置module.l = true，标识已注册 返回module.exports，也就是将这个模块的执行结果传给下一个模块 生成可执行代码前面拿到了依赖树，这一步要根据依赖树生成可在浏览器端执行的最终代码。增加一个函数genCode：1234567891011121314151617181920212223const genCode = entry =&gt; &#123; const graph = JSON.stringify(genDependenciesGraph(entry)) return ` (function(graph)&#123; // 构造require函数 function require(module) &#123; // 打包后代码里require('相对路径')，这里需要转为绝对路径才能找到模块 function localRequire(relativePath) &#123; return require(graph[module].dependencies[relativePath]); &#125; // 制造exports let exports = &#123;&#125;; (function(require, exports, code)&#123; eval(code) &#125;)(localRequire, exports, graph[module].code) return exports; &#125; require('$&#123;entry&#125;') &#125;)($&#123;graph&#125;) `&#125;const code = genCode('./src/index.js') 我们看下最终的code:12345678910111213(function(graph)&#123; function require(module) &#123; function localRequire(relativePath) &#123; return require(graph[module].dependencies[relativePath]); &#125; let exports = &#123;&#125;; (function(require, exports, code)&#123; eval(code) &#125;)(localRequire, exports, graph[module].code) return exports; &#125; require('./src/index.js')&#125;)(&#123;"./src/index.js":&#123;"dependencies":&#123;"./a.js":"./src/a.js"&#125;,"code":"\"use strict\";\n\nvar _a = _interopRequireDefault(require(\"./a.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_a[\"default\"]);"&#125;,"./src/a.js":&#123;"dependencies":&#123;"./b.js":"./src/b.js"&#125;,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _b = require(\"./b.js\");\n\nvar a = \"Hello, \".concat(_b.b);\nvar _default = a;\nexports[\"default\"] = _default;"&#125;,"./src/b.js":&#123;"dependencies":&#123;&#125;,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n value: true\n&#125;);\nexports.b = void 0;\nvar b = 'hello';\nexports.b = b;"&#125;&#125;) 复制这段代码，放到浏览器控制台，成功输出Hello, webpack，和之前用webpack打包的输出结果一致，到这里，算是完成了webpack最基础的功能。]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索组件库的最佳实践]]></title>
    <url>%2F2019%2F08%2F22%2Fvue-component-library%2F</url>
    <content type="text"><![CDATA[俗话说：写个组件库简单，写好组件库很难 本文争取不做标题党。 目标 90%+测试覆盖率 不使用template 尽可能小的打包体积 支持按需加载 支持主题定制 支持VSCode Vetur 不刻意堆砌功能 以上便是我对该组件库的期望，带着以上需求，开始着手分析 目标拆解1. 90%+测试覆盖率对于UI组件而言，过分最求测试覆盖率意义不大，所以我将90%当作测试达标线。测试工具的话有许多可供选择：jest、 mocha、karma等，我使用jest，相对其他测试框架，它的一大特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。 2.不使用template相较于template，jsx在编写复杂基础组件时往往更具优势，不使用template不是因为它不好（编写业务组件时更推荐使用template），而是我不希望在同一个组件库里同时使用jsx和template, 简化组件的编译与构建流程这一点很关键。 3.尽可能小的打包体积我使用webpack进行打包，因此需要从webpack配置着手分析。对于使用template编写的vue组件，最普通的编译方式就是webpack + vue-loader，这样做的问题在于容易引入大量冗余代码，比如：webpack内置的模块化代码、vue-loader 内置的 normalize 函数、重复引入的 babel helper 等等，而我不希望在组件的编译结果中引入这些冗余代码，那么这种情况最好使用比vue-loader更底层的一个工具: vue-template-compiler, 通过它结合babel来编译可以得到比较理想的效果。 当然我没有使用模版，而是tsx，情况就变得更加简单了, 只需要用babel将tsx编译成js不就行了吗，值得注意的是babel，需要使用@babel/plugin-transform-runtime避免重复引入helper函数(A plugin that enables the re-use of Babel’s injected helper code to save on codesize) 对于rollup，一般在打包纯js库时优势更大，所以还没有尝试用它来打包组件库。而且我看主流组件库也都是用webpack打包，因此跟着主流来没错。 4.支持按需加载这个是组件库的基本功能，一般通过配置babel-plugin-import 来做，它会在编译过程中将 import 的写法自动转换为按需引入的方式。当然，不闲麻烦手动引入所需组件也是可以的。 如果你的项目基于Typescript,那么用ts-import-plugin代替 5.主题定制我希望可以对组件样式做全局修改，而不是在使用时去覆盖组件内部类，这块可以通过less和less-loader配合babel-plugin-import来做 如果是使用.vue的组件开发方式，一般需要将样式单独抽出来而不是写在中，否则需要用到后编译。（参考cube-ui） 6.支持VSCode Vetur我希望在VSCode中使用该组件时会有自动提示，这块可以借助第三方插件生成对应的vetur json文件。 期望组件目录结构组件统一放在src/components目录下管理，每个组件的结构大致如下：12345678910111213button - demo // 组件demo - __test__ // 单元测试 - index.less - index.tsx - README.md其它组件 - demo // 组件demo - __test__ // 单元测试 - index.less - index.tsx - README.md... 期望打包结果按照目前主流的做法，输出3种格式的代码：ES Module、commonjs、UMD 所谓UMD（Universal Module Definition）指的是： 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global）。 在package.json中，设置这2种模块的入口：1234&#123; "main": "lib/index.js", // cjs "module": "es/index.js", // esm&#125; 至于UMD格式的代码，我会在最后通过webpack打包生成xpre.js和xpre.min.js并放到CDN上 期望使用方式一、按需引入（推荐）12import &#123; Button &#125; from 'xpre';Vue.use(Button) 二、全部引入（不推荐）12import Xpre from 'xpre';Vue.use(Xpre) 三、CDN引入 通常不会使用这种方式，但某些时候还是有必要的 12&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xpre@0.x/lib/index.css"&gt;&lt;script src="https://cdn.jsdelivr.net/npm/xpre@0.x/lib/xpre.min.js"&gt;&lt;/script&gt; 根据期望输入与输出构建脚本有了输入（期望组件目录结构）和输出（期望打包结果），以及使用方式，就可以着手编写构建脚本了。 1.我期望使用Vue.use(Xpre)的方式注册组件，那么Xpre必须实现install 方法，入口index.ts文件大概这样： 1234567891011121314151617181920212223242526272829import &#123; VueConstructor &#125; from 'vue/types';import Button from './components/button';// ...const components: any[] = [ Button ...];const install = (Vue: VueConstructor) =&gt; &#123; components.forEach(Component =&gt; &#123; Vue.use(Component); &#125;);&#125;;// 浏览器环境if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;// import &#123; Button &#125; from 'xpre'export &#123; install, Button&#125;// import Xpre from 'xpre'export default &#123; install&#125; 由此可见，每个组件内部如:Button，也都需要实现install方法。为了方便，写一个自动构建index.ts的脚本，以免每次新增组件的时候手动修改index.ts。 构建脚本统一在build目录下管理，新建build/build-entry.js, 它需要去遍历src/components目录来生成index.ts:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const fs = require('fs-extra');const path = require('path');const uppercamelize = require('uppercamelcase');const Components = require('./get-components')();const packageJson = require('../package.json');const version = process.env.VERSION || packageJson.version;const tips = `/* eslint-disable */`;function buildEntry() &#123; const importList = Components.map(name =&gt; `import $&#123;uppercamelize(name)&#125; from './components/$&#123;name&#125;';`); const exportList = Components.map(name =&gt; `$&#123;uppercamelize(name)&#125;`); const content = `$&#123;tips&#125;import &#123; VueConstructor &#125; from 'vue/types';$&#123;importList.join('\n')&#125;declare global &#123; interface Window &#123; Vue?: VueConstructor; &#125;&#125;const components: any[] = [ $&#123;exportList.join(',\n ')&#125;];const install = (Vue: VueConstructor) =&gt; &#123; components.forEach(Component =&gt; &#123; Vue.use(Component); &#125;);&#125;;/* istanbul ignore if */if (typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export &#123; install, $&#123;exportList.join(',\n ')&#125;&#125;;export default &#123; install&#125;;`; // 输出内容到index.ts fs.writeFileSync(path.join(__dirname, '../src/index.ts'), content);&#125;buildEntry(); 2.处理了入口文件，接下来需要编译组件了 新建build/build-components.js, 它需要递归地去编译src目录下的所有js|ts|tsx文件，并最终生成es和lib两个编译后的目录，使用babel来进行编译：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const fs = require('fs-extra');const path = require('path');const babel = require('@babel/core');const esDir = path.join(__dirname, '../es');const libDir = path.join(__dirname, '../lib');const srcDir = path.join(__dirname, '../src');const babelConfig = &#123; configFile: path.join(__dirname, '../babel.config.js')&#125;;const scriptRegExp = /\.(js|ts|tsx)$/;const isDir = dir =&gt; fs.lstatSync(dir).isDirectory();const isCode = path =&gt; !/(demo|test|\.md)$/.test(path);const isScript = path =&gt; scriptRegExp.test(path);// 分别编译es/lib两个目录function compile(dir) &#123; const files = fs.readdirSync(dir); files.forEach(file =&gt; &#123; const filePath = path.join(dir, file); // 除了js|ts|tsx文件一律不管 if (!isCode(file)) &#123; return fs.removeSync(filePath); &#125; // 递归编译 if (isDir(filePath)) &#123; return compile(filePath); &#125; // compile if (isScript(file)) &#123; // 根据定义的babel规则生成code // 移除原文件（js|ts|tsx） // 生成新文件（js） const &#123; code &#125; = babel.transformFileSync(filePath, babelConfig); fs.removeSync(filePath); fs.outputFileSync(filePath.replace(scriptRegExp, '.js'), code); &#125; &#125;);&#125;// clear dirfs.emptyDirSync(esDir);fs.emptyDirSync(libDir);// compile es dirfs.copySync(srcDir, esDir);compile(esDir);// compile lib dir// 设置环境变量，在babel.config.js里会根据该环境变量输出不同的模块process.env.BABEL_MODULE = 'commonjs';fs.copySync(srcDir, libDir);compile(libDir); 上面的构建脚本是根据babel.config.js的配置而来，那么它大概需要如下配置：12345678910111213141516171819202122232425262728293031323334353637383940module.exports = function () &#123; const &#123; BABEL_MODULE, NODE_ENV &#125; = process.env; const useESModules = BABEL_MODULE !== 'commonjs' &amp;&amp; NODE_ENV !== 'test'; return &#123; presets: [ [ '@babel/preset-env', // 环境预设 &#123; // 默认为false，设置为true可减少编译后代码量 loose: true, // "amd" | "umd" | "systemjs" | "commonjs" | "cjs" | "auto" | false, defaults to "auto" // 表示ES6语法的编译目标，false表示不转换，commonjs等同于cjs modules: useESModules ? false : 'cjs' &#125; ], [ // Configurable preset for Vue JSX plugins '@vue/babel-preset-jsx', &#123; functional: false &#125; ], // 解析.ts '@babel/preset-typescript' ], plugins: [ [ '@babel/plugin-transform-runtime', &#123; corejs: false, helpers: true, regenerator: false, useESModules &#125; ], '@babel/plugin-transform-object-assign' ] &#125;;&#125;; 除了配置一些presets和plugins外，还需要根据环境变量改变打包的模块格式。这里的插件@babel/plugin-transform-runtime前面也提到过，注意regenerator: false这个选项，表示不重复生成helper函数，否则打包后会多出许多冗余代码 3.接下来需要编译组件样式，将.less文件经过一系列编译转化成最终的.css 需要用到的工具大致如下：12345// build/build-style.js const less = require('less'); // less -&gt; cssconst postcss = require('postcss'); // 对css进行后处理const csso = require('csso'); // css压缩优化 4.接下需要根据生成的样式生成组件的style入口，这块需要注意的是生成样式目录的结构，因为我需要组件在使用时能够结合babel-plugin-import来做样式的按需加载和主题定制 通过babel-plugin-import的示例说明：12345678910// &#123; "libraryName": "antd", style: true &#125;import &#123; Button &#125; from 'antd';ReactDOM.render(&lt;Button&gt;xxxx&lt;/Button&gt;); ↓ ↓ ↓ ↓ ↓ ↓var _button = require('antd/lib/button');require('antd/lib/button/style');ReactDOM.render(&lt;_button&gt;xxxx&lt;/_button&gt;); 可以发现，其实通过设置style: true，在按需引入组件Button时就能自动帮我们引入对应的样式，因此何不模仿antd，在对应组件下生成style.js:1require('xxx.css') 当然这样不够，因为前面我说过要做主题定制，我还需要生成一个less.js：1require('xxx.less') 到这里最终的编译生成的组件样式结构应该是这样：123style - index.js // 用于结合babel-plugin-import做组件样式的自动按需加载 - less.js // 用于结合babel-plugin-import做主题定制 5.完成了前面的工作，主题定制可以参考以下配置 在配置babel-plugin-import的时候可以这样做：12345678910// babel.config.jsmodule.exports = &#123; plugins: [ ["import", &#123; "libraryName": "xpre", "libraryDirectory": "es/components", "style": name =&gt; `$&#123;name&#125;/style/less` &#125;] ]&#125; 然后根据less提供的modifyVars修改less变量达到目的：123456789101112131415161718module.exports = &#123; rules: [ &#123; test: /\.less$/, use: [ &#123; loader: 'less-loader', options: &#123; modifyVars: &#123; red: 'red', blue: 'blue' &#125; &#125; &#125; ] &#125; ]&#125;; 分析到这里就可以写构建样式入口的脚本了，这块做起来会麻烦些，需要根据样式的依赖关系去确定样式入口依赖的样式文件。 6.根据生成的es/index.js打包生成umd格式代码 对应的webpack配置就简单许多了：12345678910111213141516171819202122232425module.exports = Object.assign(config, &#123; mode: 'production', entry: &#123; xpre: './es/index.js' &#125;, output: &#123; path: path.join(__dirname, '../lib'), library: 'xpre', libraryTarget: 'umd', filename: isMinify ? '[name].min.js' : '[name].js' &#125;, // 防止将vue打到bundle中 externals: &#123; vue: &#123; root: 'Vue', commonjs: 'vue', commonjs2: 'vue', amd: 'vue' &#125; &#125;, performance: false, optimization: &#123; minimize: isMinify &#125;&#125;); 这一步后会在lib目录下生成xpre.js和xpre.min.js 到这里，组件的编译工作就正式结束了，这个过程我去了解了大量的组件库的编译流程，虽说百花齐放，但总的原理相通，这个过程没有人带的话还是需要踩许多坑的。接下来可以正式开始写组件了。题外话——关于组件库命名之前我给组件库的命名是带scope的，比如：@scope/xxx, 后来我发现通过以下方式无法引入组件库：12345import Xpre from '@scope/xxx'// Xpre is not defined// 这种情况需要手动指定路径才能正确导入，如下：import Xpre from '@scope/xxx/lib' 这个诡异的bug，我目前也找不到原因，索性重新命名，去掉scope就好了。因此组件库的包名最好不要带上scope]]></content>
      <categories>
        <category>组件库</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0实现call()/apply()/bind()]]></title>
    <url>%2F2019%2F06%2F05%2Fbind%2F</url>
    <content type="text"><![CDATA[call()/apply()在工作中有着诸多的应用，本着知其然知其所以然的原则，现在我们从0来实现call/apply/bind。其实也很简单，思路很重要。 call()想要实现call，我们得先了解其核心原理：改变函数体内的this指向(查看MDN官方解释)。因此从一下几点入手： 将函数设置为对象的属性fn 拿到arguments传给fn并执行 删除fn，还原对象 1234567891011121314151617181920if(typeof Function.prototype.mycall !== 'function') &#123; Function.prototype.mycall = function(obj) &#123; let args; if(Object.prototype.toString.call(obj) !== '[object Object]') &#123; obj = window; // if in node: obj = global; &#125; args = [...arguments].slice(1); // 获取参数 obj.fn = this; // 将函数设置为对象的属性fn obj.fn(...args); // 传入参数并执行fn delete obj.fn; // 删除属性fn &#125;&#125;var value = 'global value';var bar = &#123; value: 'local value' &#125;;function foo(a, b) &#123; console.log(a, b) console.log(this.value)&#125;foo.mycall(bar, 1, 2) //1，2，'local value'foo.mycall(null, 1, 2) // 1, 2, 'global value' apply()那么对于apply，除了参数的传递形式不同外，原理同call： 123456789101112if(typeof Function.prototype.myapply !== 'function') &#123; Function.prototype.myapply = function(obj) &#123; if(Object.prototype.toString.call(obj) !== '[object Object]') &#123; obj = window; &#125; obj.fn = this; obj.fn(...arguments[1]); // 因为第二个参数是array，直接获取第二个参数并传入fn调用 delete obj.fn; &#125;&#125; bind() bind()方法创建一个新的函数，在调用时设置this关键字为提供的值。并在调用新函数时将给定参数列表作为原函数的参数序列的前若干项 MDN示例：123456789101112131415var module = &#123; x: 42, getX: function() &#123; return this.x; &#125;&#125;var unboundGetX = module.getX;console.log(unboundGetX()); // The function gets invoked at the global scope// expected output: undefinedvar boundGetX = unboundGetX.bind(module);console.log(boundGetX());// expected output: 42// this equal to unboundGetX.call(module) 简单实现的话，我们可以在mybind()内返回一个匿名函数，该函数内部通过call()来改变this指向，从而模拟出bind()方法 12345678if(typeof Function.prototype.mybind !== '[object Object]') &#123; Function.prototype.mybind = function(obj) &#123; let fn = this; return function() &#123; return fn.call(obj); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript函数柯里化]]></title>
    <url>%2F2019%2F05%2F31%2Fcurry%2F</url>
    <content type="text"><![CDATA[Function Apply在一些存粹的函数式编程语言中，函数并不是被描述为called或invoked，而是描述为applied。在js里面，通过Function.prototype.apply()可以实现Function Apply。 下面是一个函数应用的例子： 1234567function say(s) &#123; return "Hello" + s;&#125;//调用函数say("world");//应用函数say.apply(null, ["world"]) 在上面的例子中，invoking和applying可以得到相同的结果。apply()接受两个参数：第一个参数为将要绑定到该函数体内this的一个对象，第二个参数为一个数组。如果第一个参数为空，那么this指向全局。 除了apply()以外，还有call()方法，它仅仅只是apply()的语法糖。当函数仅有一个参数时，推荐使用call代替apply，因为可以避免创建只有一个元素的数组，减小内存开销。 为了达到最佳新能，Node的Event模块就在三个参数以下用call否则用apply （我写了一篇文章，如何从0实现call/apply/bind方法） Currycurry化就是将完全应用函数变为部分应用函数的过程（简单来说就是通过改变传递给函数参数的个数来达到改变函数返回结果） 先举个简单点的🌰： 12345678910111213function add(x, y) &#123; //部分应用 if(typeof y === "undefined") &#123; return function(y) &#123; return x + y &#125; &#125; //完全应用 return x + y&#125;add(1)(2) // 3（部分应用）add(1, 2) // 3（完全应用） 上面的代码比较容易理解：如果同时传递x和y，会走直接return x+y；但如果只传一个x，那会返回一个新的函数，并将之前传递的x保存起来供下次函数应用 然后实现一个通用的curry函数：12345678910111213141516function curry(fn) &#123; const slice = Array.prototype.slice; let savedArgs = slice.call(arguments, 1);//剔除第一个参数（fn）, 将类数组对象转化为数组 return function() &#123; let newArgs = slice.call(arguments); let args = [...savedArgs, ...newArgs]; return fn.apply(null, rags); &#125;&#125;//定义一个普通函数function add(x, y, z) &#123; return x + y + z&#125;//curry化curry(add, 1)(2, 3) // 6 何时使用Curry化当正在调用同一个函数，并且传递的参数大多都是相同的，那么该函数可能是用于curry化的一个很好的候选参数。可以通过将一个函数集合部分应用到函数中，从而动态创建一个新函数。 举个简单的🌰：12345678910111213141516171819202122function curry(func, args = []) &#123; let arity = func.length; return function (..._args) &#123; _args.unshift(...args); if(_args.length &lt; arity) &#123; return curry.call(null, func, _args); &#125; return func(..._args); &#125;&#125;function checkFun(reg, str) &#123; return reg.test(str);&#125;let check = curry(checkFun);let checkPhone = check(/^1[34578]\d&#123;9&#125;$/);console.log(checkPhone('13997603799')) //truelet checkEmail = check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);console.log(checkEmail('839862975@qq.com')) //true 在vue源码里面也有大量函数curry化的应用。比如vue在将VNode进行patch生成真实DOM的过程中，为了抹平平台差异（web和weex），将平台差异化的参数提前固化，这样不用每次调用patch方法的时候都传递nodeOps和modules了 nodeOps 表示对 “平台 DOM” 的一些操作方法，modules 表示平台的一些模块，它们会在整个 patch 过程的不同阶段执行相应的钩子函数1234567891011//plantforms/web/runtime/patch.jsimport * as nodeOps from 'web/runtime/node-ops'import &#123; createPatchFunction &#125; from 'core/vdom/patch'import baseModules from 'core/vdom/modules/index'import platformModules from 'web/runtime/modules/index'// the directive module should be applied last, after all// built-in modules have been applied.const modules = platformModules.concat(baseModules)export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写一个webpack plugin吧]]></title>
    <url>%2F2019%2F05%2F24%2Fwebpack-plugin%2F</url>
    <content type="text"><![CDATA[什么是plugin？webpack在运行过程中会广播许多事件，plugin可以监听这些事件，以在一定的时机去执行一些事情去改变输出结果。 copyright-webpack-plugin先写个简单的plugin，有个直观的印象后再具体介绍相关内容。 这个plugin会在webpack打包输出资源到目标文件夹之前生成一个copyright.txt文件 1234567891011121314151617181920212223// plugins/copyright-webpack-plugin.jsclass CopyrightWebpackPlugin &#123; constructor(options) &#123; this.content = options.content &#125; apply(compiler) &#123; compiler.hooks.compile.tap('CopyrightWebpackPlugin', (compilation) =&gt; &#123; console.log('compile') &#125;) compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (compilation, cb) =&gt; &#123; // compilation: 本次打包的内容 // compilation.assets： 本次打包生成的文件 // debugger compilation.assets['copyright.txt'] = &#123; source: () =&gt; this.content, size: () =&gt; this.content.length &#125; cb() &#125;) &#125;&#125;module.exports = CopyrightWebpackPlugin 使用：12345678910// webpack.config.jsconst CopyrightWebpackPlugin = require(&apos;./plugins/copyright-webpack-plugin&apos;)module.exports = &#123; plugins: [ new CopyrightWebpackPlugin(&#123; content: &apos;Copyright by xietian&apos; &#125;) ]&#125; Webpack 启动后，在读取配置的过程中会先执行 new CopyrightWebpackPlugin(options），初始化 CopyrightWebpackPlugin 并获得其实例。 在初始化 compiler 对象后，再调用 CopyrightWebpackPlugin.apply (compiler）为插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.hooks.eventName.tap（插件名称，回调函数）监听到 Webpack 广播的事件，并且可以通过 compiler 对象去操作 Webpack compiler和compilation在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation ，它们是 Plugin 和 Webpack之间的桥梁。Compiler 和 Compilation 的含义如下: Compiler 对象包含了 Webpack 环境的所有配置信息，包含 options loaders plugins等信息。这个对象在Webpack启动时被实例化，它是全局唯一的，可以简单地将它理解为 Webpack 实例 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack以开发模式运行时，每当检测到一个文件发生变化，便有一次新的 Compilation创建。Compilation 对象也提供了很多事件回调供插件进行扩展。通过 Compilation也能读取到 Compiler 对象。 Compiler 和 Compilation都继承自Tapable ++Compiler Compilation 的区别在于： Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只代表一次新的编译++。 Plugin API这里只介绍一些常用的Plugin ApI 读取输出资源、代码块、模块及其依赖emit hook表示资源编译完毕，生成资源到 output 目录之前，在这里可以修改输出内容12345678910111213141516171819class Plugin &#123; apply(compiler) &#123; compiler.hooks.emit.tapAsync('Plugin', (compilation, cb) =&gt; &#123; // compilation.chunks是一个数组，用于存放所有代码块 cimpilation.chunks.forEach(chunk =&gt; &#123; // 一个代码块由多个模块组成，chunk.forEachModule遍历其中的模块 chunk.forEachModule(module =&gt; &#123; // module.fileDependencies是一个数组, 存放当前模块的所有依赖的文件路径 module.fileDependencies.forEach(filePath =&gt; &#123;&#125;) &#125;) // Webpack会根据Chunk生成输出的文件资源，每个 Chunk 都对应 一个及以上的输出文件, 例如在 Chunk 中包含 css 模块并且使用了 ExtractTextPlugin 时，该 Chunk 就会生成 js/css两个文件 &#125;) &#125;) &#125;&#125; 监听文件变化Webpack 会从配置的入口模块出发，依次找出所有依赖模块， 当入口模块或者其依赖的模块发生变化时 就会触发一次新的 Compilation watchRun hook: 一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前 待续…]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个webpack loader吧]]></title>
    <url>%2F2019%2F05%2F23%2Floader%2F</url>
    <content type="text"><![CDATA[什么是loader？Loader可以理解为模块转换器，作用是将原内容按照一定的规则生成新内容 以处理.scss文件为例： 将.scss文件交给scss-loader处理，转化为.css文件 将.css文件交给css-loader处理，找出其中依赖的资源，压缩css等 将css-loader输出的css交给style-loader处理，转换成通过脚本加载的js代码 对应webpack配置如下：12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\.scss/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; minimize: true &#125; &#125;, &#123; loader: 'scss-loader' &#125; ] &#125; ] &#125;&#125; 由此可以发现loader的责任是单一的：一个loader只负责做一件事情，通过链式调用的方式来达到我们处理文件的目的。我们自己在编写loader的时候也需要遵循这一原则。 loader的本质webpack运行于node.js之上，一个loader本质上就是一个node.js模块，这个模块通过module.exports导出一个函数，原内容为该函数的参数，通过处理后返回新内容 loader API loader API用于webpack和loader之间进行通信（loader API 文档） 接下来我会对常用的loader api进行解释 1. 获取loader的options1234567const loaderUtils = require('loader-utils')module.exports = function(source) &#123; // 以上面的css-loader为例, // 这里的options: &#123; minimize: true &#125; const options = loaderUtils.getOptions(this) return source&#125; 2. 返回其它结果上面的例子未将内容处理就返回了，在某些时候我们可能需要返回一些额外的信息，比如sourceMap。 以babel-loader转化es6语法为例，它还需要输出转化成es5语法后对应的sourceMap，以便于调试代码：123module.exports = function(source) &#123; this.callback(null, source, sourceMap)&#125; 没错，这里的关键就是callback api，它的详细使用如下：123456this.callback( err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any); 关于sourceMap： 一般只在开发环境下生成，因为生成sourceMap十分耗时，生产环境关闭sourceMap以加速构建速度。this.sourceMapAPI告诉loader在当前构建环境是否需要sourceMap。如果我们编写的loader会生成SourcMap，请铭记这一点 3. 同步与异步前面的示例都是同步的，如果我们要在loader中进行异步操作，那么需要使用this.asyncAPI123456module.exports = function(source) &#123; const callback = this.async() settimeout(() =&gt; &#123; callback(null, source, sourceMap) &#125;)&#125; 4. 处理二进制数据在默认情况下， Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。但在某些场景下 Loader 不会处理文本文件，而会处理二进制文件如 file-loader ，这时就需要 Wepack为Loader传入二进制格式的数据。为此，我们需要这样编写 Loader:123456module.exports = function(source) &#123; console.log(source instanceof Buffer) // true&#125;// 这行代码使loader获取的source为二进制数据module.exports.raw = true 暂时只介绍这几个api，查看官方文档了解更多吧。 本地loader的使用在开发过程中，我们需要本地加载loader而不是把loader传到npm再使用。如何做到以loader: &#39;xxx-loader&#39;的形式使用而不是loader: path.resolve(__dirname, &#39;./loaders/xxx-loader&#39;)，这时候就需要resolveLoader选项了，它告诉webpack怎么去查找loader：123456module.exports = &#123; resolveLoader: &#123; // 在哪里查找loader，有先后顺序 modules: ['node_modules', './loaders'] &#125;&#125; 当然，除了上面的方式，通过npm link将本地loader目录建立一个软连接到node_modules，也可以达到相同的目的。 以markerdown2vue-loader为例 markerdown2vue-loader是我写的一个简单的loader，用于将markdown转为vue，当我们想用markdown来生成网站时特别有用。事实上，我的组件库文档就是这么干的。 思路 将.md转化为对应的dom结构（比如## -&gt; h2、### -&gt; h3等等）,这时候得到的dom结构十分扁平，所以暂且称之为raw dom, 这一过程中要处理一系列问题，如：语法高亮、锚点、解析emoji等 再将raw dom进行自定义分层处理（比如在该loader中我是利用h3来进行划分，在其外包一个&lt;div class=&quot;card&quot;&gt;&lt;/div&gt;） 最后则是返回&lt;template&gt;&lt;/template&gt;供vue-loader处理 具体实现 将.md转化为对应的dom结构新建index.js： 123456789101112131415161718192021222324module.exports = function (source) &#123; let options = loaderUtils.getOptions(this) || &#123;&#125;; this.cacheable &amp;&amp; this.cacheable(); options = &#123; wrapper, ...options &#125;; // 主要利用markdown-it这个库，同时使用了相关插件 const parser = new MarkdownIt(&#123; html: true, highlight &#125;).use(anchor, &#123; permalink: true, permalinkBefore: true, permalinkSymbol: options.linkSymbol || '👉🏻', level: 1, slugify &#125;).use(emoji); // 经过parser.render(source)处理后会生成raw dom，传给wrapper做分层处理 return options.wrapper(parser.render(source));&#125;; 将raw dom进行自定义分层处理 新建card-wrapper.js:12345678910111213141516171819module.exports = function cardWrapper(html) &#123; // html字符串转换为 h2/h3分类的数组 const DIVIDE_ID = ':::'; const DIVIDE_ID_H2 = DIVIDE_ID + '&lt;h2'; const DIVIDE_ID_H3 = DIVIDE_ID + '&lt;h3'; const group = html.replace(/&lt;h3/g, DIVIDE_ID_H3).replace(/&lt;h2/g, DIVIDE_ID_H2).split(DIVIDE_ID); return group .map(fragment =&gt; &#123; // 以h3划分card // h3后的非h2/h3节点都会放进card if (fragment.indexOf('&lt;h3') !== -1) &#123; return `&lt;div class="card"&gt;$&#123;fragment&#125;&lt;/div&gt;`; &#125; return fragment; &#125;) .join('');&#125;; 返回vue-template供vue-loader使用 wrapper函数如下： 1234567891011function wrapper(content) &#123; content = cardWrapper(content); content = encodeURIComponent(content); // 使用v-once保证其只渲染一次 return ` &lt;template&gt; &lt;section v-html="decodeURIComponent(\`$&#123;content&#125;\`)" v-once /&gt; &lt;/template&gt; `;&#125; 实际上到这里loader就写完了，使用的话就很简单了：123456789&lt;template&gt; &lt;md /&gt;&lt;/template&gt;export default &#123; components: &#123; Md: () =&gt; import('./xxx.md') &#125;&#125;]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于rust构建一个wasm模块并且发布到npm]]></title>
    <url>%2F2019%2F05%2F22%2Frust-wasm%2F</url>
    <content type="text"><![CDATA[目的本文试图基于rust构建一个wasm模块并且发布到npm！ 工具 在这之前，我们需要安装好必要的工具 [x] 安装rust 这步不多说了，安装后在终端输入rustc --version如果出现以下提示说明安装成功: 1rustc 1.34.1 (fc50f328b 2019-04-24) 安装rust的同时也会默认安装cargo，这是rust官方的包管理工具，类似node中的npm [x] 安装wasm-pack 它会帮助我们把我们的代码编译成 WebAssembly 并制造出正确的 npm 包 1cargo install wasm-pack 新建项目1cargo new --lib hello_wasm 执行上面命令会创建一个新项目，目录结构很简单：123-- Cargo.toml-- src -- lib.rs Cargo.toml就是项目配置文件，我们需要增加一些配置：12345[lib]crate-type = ["cdylib"][dependencies]wasm-bindgen = "0.2" 我们需要依赖wasm-bindgen，并且指定了版本号（0.2.x） 同时指定了crate-type=[&quot;cdylib&quot;],意思是编译成一个可以被其它语言加载的动态库。 查看官方文档 写点代码在src/lib.rs下：123456789101112131415extern crate wasm_bindgen;use wasm_bindgen::prelude::*;// 告诉rust需要导入的js函数，这里我们拿到了window.alert#[wasm_bindgen]extern &#123; pub fn alert(s: &amp;str);&#125;// 导出可以被js调用的函数greet()#[wasm_bindgen]pub fn greet(name: &amp;str) &#123; alert(&amp;format!("Hello, &#123;&#125;", name));&#125; 构建包1wasm-pack build --scope my_npm_username 运行wasm-pack build帮我们做了一系列的事情： 将rust编译成WebAssembly 在生成的WebAssembly上运行wasm-bindgen, 从而产生一个包装了WebAssembly的npm模块 创建了一个pkg文件夹，里面包含了生成的.wasm和.js文件 根据Cargo.toml在pkg下生成对应的package.json文件 拷贝 README.md (如果存在) 到pkg下 发布包到npm123cd pkgnpm publish . 到这步以后，我们就可以在npm上看到刚刚发布的包了，如果你在build的时候指定了scope, 那么包名就是@my_npm_username/hello_wasm 使用包 新建一个前端工程 12345678910111213141516171819&#123; "name": "wasm-test", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "dev": "webpack-dev-server" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "@tian0o0/hello_wasm": "^0.1.0" &#125;, "devDependencies": &#123; "webpack": "^4.31.0", "webpack-cli": "^3.3.2", "webpack-dev-server": "^3.3.1" &#125;&#125; 12345678910// webpack.config.jsconst path = require('path');module.exports = &#123; entry: "./index.js", output: &#123; path: path.resolve(__dirname, "dist"), filename: "index.js", &#125;, mode: "development"&#125;; 1234567891011&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello-wasm example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234// index.jsimport("@tian0o0/hello_wasm").then(module =&gt; &#123; module.greet("world");&#125;); 前端代码写好后：12npm installnpm run dev 打开localhost:8080, 看到弹框提示Hello, world，说明已经成功了。 rust-webpack-template前面我们通过一系列操作将rust编译成wasm再发布到npm才能使用，十分不方便，还好rustwasm官方为我们提供了rust-webpack-template 1. 运行下面命令拉取模板1npm init rust-webpack your_app_name 该项目的初始结构如下：123456789101112131415├── LICENSE-APACHE├── LICENSE-MIT├── README.md├── crate│ ├── Cargo.lock│ ├── Cargo.toml│ ├── pkg│ ├── src│ └── target├── index.html├── js│ └── index.js├── package-lock.json├── package.json└── webpack.config.js 执行 npm run build将生产dist目录：12345├── dist│ ├── 1.bundle.js│ ├── 362e0215e53c5653c642.module.wasm│ ├── bundle.js│ └── index.html 执行npm start将通过webpack-dev-server开启本地服务，修改src下的rust代码，也可以获得热更新的效果，大大提高了开发效率。 总结本文所做的事情十分简单，事实上，目前wasm适用的场景并不多，比如：图像处理、音视频处理、h5游戏等需要在前端进行复杂运算的场景，希望以后能有机会在项目中实战。]]></content>
      <categories>
        <category>wasm</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>wasm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做一个chrome扩展吧]]></title>
    <url>%2F2019%2F03%2F20%2Fchrome-extension%2F</url>
    <content type="text"><![CDATA[TO DO还没有好的点子]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack优化之道]]></title>
    <url>%2F2018%2F10%2F25%2Fwebpack%2F</url>
    <content type="text"><![CDATA[优化1.缩小文件搜索范围1.1优化loader配置 由于 Loader 对文件的转换操作很耗时，所以需要让尽可能少的文件被 Loader 理。 通过test、include、exclude去确定哪些文件需要被处理123456789101112//以babel-loader为例：module.exports = &#123; module: &#123; rules: [ &#123; test: /.js$/, use: ['babel-loader?cacheDirectory'], include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; 1.2优化resolve.modules配置 resolve.modules用于配置webpack去哪些目录寻找三方模块 默认值为：[‘node_modules]。 含义是先去当前目录的 node_modules 目录下去找我们想找的模块，如果没找到 就去上一级目录./node_modules中找，再没有就去 ../../node_modules 中找，以此类推 这和 node.js 的模块寻找机制很相似。 当安装 的第三方模块都放在项目根目录的 node modules 目录下时，就没有必要按照默认 的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找12345module.exports = &#123; resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')] &#125;&#125; 1.3优化resolve.mainField配置 在安装的第三方模块中都会有一个 package.json 文件，用于描述这个模块的属性其中的某些字段用于描述入口文件在哪里， resolve.mainFields用于配置采用哪个字段作为入口文件的描述 可以存在多个字段描述入口文件的原因是，某些模块可以同时用于多个环境中，针对不同的运行环境需要使用不同的代码。以 isomorphic-fetch ( https://github.corn/matthewandrews/isomorphic-fetch）为例，它是 fetch API ( https://developer.mozilla.org/zh-CN/docs/Web/APl/Fetch_API) 的一个实现，但可同时用于浏览器和 Node.js 环境 在它的 package. jsoη中就有两个入口文件描述字段：1234&#123;"browser":”fetch-npm-browserify.js”,"main":”fetch-npm-node.js ”&#125; isomo hic-fetch 在不同的运行环境下使用不同的代码，是因为 fetch API 的实现机制不样，在浏览器中通过原生的 fetch 或者 XMLHttpRequest 实现，在 Node. j 通过http 模块实现。 resolve.mainFields 的默认值和当前的 target 配置有关系，对应的关系如下。 target web 或者 webworker 时，值是［”browser ”，” module ”，”ma in ］。 target 为其他情况时，值是［ “module ”，”main ”］。 以target 等于 web 为例， Webpack 会先采用第三方模块中的 browser 宇段去寻找模块的入口 文件，如果不存在，就采用 module 字段，以此类推。为了减少搜索步骤，在明确第 方模块的入口文件描述字段时，我们可以将它设置得尽量少。 由于大多数第三方模块都采用 main 宇段去描述入口文件的位置，所以可以这样配置:12345module.exports = &#123; resolve: &#123; mainFields: ['main'] &#125;&#125; 1.4优化resolve.alias 在默认情况下， Webpack 会从入口文件./node_modules/vue/dist/vue.js开始递归解析和处理依赖的几十个文件，这会是一个很耗时的操作 通过配置 resolve. alias,可以让 Webpack 在处理 vue 时，直接使用单独、完整的 vue.esm.js 文件 ，从而跳过耗时的递归解析操作1234567module.exports = &#123; resolve: &#123; alias: &#123; 'vue$': path.resolve(__dirname, './node_modules/vue/dist/vue.runtime.esm.js') &#125; &#125;&#125; 但是，对某些库使用本优化方法后，会影响到后面要讲的使用 Tree-Sharking 去除无效代码的优化，因为打包好的完整文件中有部分代码在我们的项目中可能永远用不上。一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是 个整体，每 行都是不可或缺的 但是对于 些工具类的库如 lodash ，我们的项目中可能只用到了其中几个工具函数，就不能使用本方法去优化了，因为这会导致在我们 的输出代码中包含很多永远不会被执行的代码。 1.5优化resolve.extensions例如：1extensions :[’ .js ’,’.json ’] 也就是说，当遇到 require ( ‘. /data ’） 这样的导入语句 webpack 会先去寻找.／ data.js 文件，如果该文件不存在，就去寻找 data.json 文件，如果还是找不到就报错。 如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以resolve .extensions 的配置也会影响到构建的性能 在配置 resolve.extensions时需要遵守 以下几点，以做到尽可能地优化构建性能。 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程。 在源码中写导入语句时，要尽可能带上后缀 从而可以避免寻找过程。例如在确定的情况下将 require ( ’. /data ’） 写成 require （’. data.json’） 1.6优化module.noParse module.noParse 配置项可 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。原因是一些库如 jQuery庞大又没有采用模块化标准，让 Webpack 解析这些文件既耗时又没有意义。 在前面讲解优化 resolve.alias 配置时讲到，单独、完整的 vue.esm.js 文件没有采用模块化，让我们通过配置 module.noParse 忽略对它的递归解析处理，相关的 Webpack 配置如下：12345module.exports = &#123; module: &#123; noParse: [/vue\.runtime\.esm\.js$/] &#125;&#125; 2.使用DllPlugin为web项目接入动态链接库（dll） 1.将网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中 。在一个动态链接库中可以包含多个模块。 2.当需要导入的模块存在于某个动态链接库 中时，这个模块不能被再次打包，而是去动态链接库中获取。 3由于动态链接库中大多数包含的是常用的第 方模块，例如 vue、vue-router ，所以只要不升级这些模块的版本，动态链接库就不用重新编译。 在webpack中，通过以下两个插件实现dll： DllPlugin: 用于打包出一个个单独的动态链接库文件 DllReferencePlugin: 用于在主要的配置文件中引入 DllPlugin 插件打包好的动态链接库文件。 实现过程： 1、动态链接库文件相关的文件需要由 份独立的构建输出，用于为主构建使用。新建webpack.dll.conf.js12345678910111213141516171819202122232425262728293031const path = require('path')const DllPlugin = require('webpack/lib/DllPlugin')function resolve(dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; entry: &#123; vue: ['vue/dist/vue.runtime.esm.js', 'vue-router', 'vuex'], // vant: ['vant'] &#125;, output: &#123; path: resolve('dist'), filename: '[name].dll.js', // 存放动态链接库的全局变量名称，_dll_vue library: '_dll_[name]' &#125;, plugins: [ new DllPlugin(&#123; /* *动态链接库的全局变量名称，需要和 output.library 中的保持一致 *该字段的值也就是输出的 manifest json 文件中 name 字段的值 *例如在 react.manifest json 中就有 ”name“：”_dll_vue" */ name: '_dll_[name]', //描述动态链接库的 manifest json 文件输出时的路径以及文件名称 path: resolve('dist/[name].manifest.json'), context: __dirname &#125;) ]&#125; 2、根据webpack.dll.conf.js构建动态链接库文件及其描述文件。创建build.dll.js123456789101112131415161718192021222324252627282930313233343536373839'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const ora = require('ora')const rm = require('rimraf')const path = require('path')const chalk = require('chalk')const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.dll.conf')const spinner = ora('building for dll...')spinner.start()// rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123;// if (err) throw err // &#125;)webpack(webpackConfig, function (err, stats) &#123; spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' Build failed with errors.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build complete.\n')) &#125;) 这步以后会在dist目录下产生： vue.dll.js vue.manifest.json (描述vue.dll.js中包含哪些模块) 3、修改webpack.prod.conf.js，加入DllReferencePlugin1234567891011const DllReferencePlugin = require('webpack/lib/DllReferencePlugin')//告 Webpack 使用了哪些动态链接库new DllReferencePlugin(&#123;// 描述vue动态链接库的文件内容 manifest: require('../dist/vue.manifest.json'), context: __dirname&#125;),//如果有多个动态链接库文件// new DllReferencePlugin(&#123;// manifest: ...// &#125;), 4、在根目录index.html中引入vue.dll.js12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src="./vue.dll.js"&gt;&lt;/script&gt;&lt;/body&gt; 5、npm run build执行构建，可以发现构建速度有了明显的提升 3.Tree Shaking 要让 Tree Shaking 正常工作的前提是，提交给 Webpack JavaScript 代码必须采用了 ES6 的模块化语法。 因为 ES6 模块化语法是静态的（在导入、导出语句中的路径是静态的字符串，而且不能放入其他代码块中），这让 Webpack 可以简单地分析出哪些expo rt 的被 import 了。如果采用了 S5 中的模块化，例如 module.export={ … ｝、require (x+y ）、 if (x) {require （’.／ util ’）｝，则 Webpack 无法分析出可以剔除哪些代码 实现过程: 1. 修改.babelrc1234567&#123;"presets": [ ["env", &#123; "modules": false //关闭 babel 的模块转换功能，保留原本的 ES6语法。 &#125;] ]&#125; 2. 以lodash库为例 往往我们在项目中使用lodash只会用到其提供部分方法，如果我们要tree shaking lodash，应该安装lodash-es而不是lodash，因为lodash库本身是commonjs的模块，不支持tree shaking.同时想要使tree shaking生效，还需要两个插件： babel-plugin-lodash lodash-webpack-plugin 12345// webpack.prod.conf.jsconst LodashModuleReplacementPlugin = require('lodash-webpack-plugin');plugins: [ new LodashModuleReplacementPlugin()] 在import时:12// import _ from 'lodash-es'import &#123; chunk &#125; from 'lodash-es' 这样一来在构建以后lodash就shaking到无影无踪了 2. 以vant组件库为例查看vant的package.json,发现：12"main": "lib/index.js", //commonjs"module": "es/index.js", //esm 在项目中使用大量的第 方库时，我们会发现 Tree Shaking 似乎不生效了，原因是大部分Npm 中的代码都采用了 CommonJS 语法，这导致 Tree shaking 无法正常工作而降级处理。但幸运的是，有些库考虑到了这 点，这些库在发布到 Npm 上时会同时提供两份代码，一份采 CommonJs 模块化语法，一份采用 ES6 模块化语法。并且在 package json 文件中别指出这两份代码的入口。 之前介绍过 mainFields 用于配置采用哪个字段作为模块的入口描述。为了Tree Shaking vant 生效，需要配置 Webpack 的文件寻找规 如下:12345module.exports= &#123; resolve: &#123; mainFields: ['module', 'main', 'browser'] &#125;&#125; 以上配置的含义是优先使用 module 作为入口，如果不存在，就会采用 browser 或者 main 并将其作为入口 社区约定：用 jsnext:main 作为 ES6 模块化代码的入口 要实现按需导入vant组件，需要一个插件：babel-plugin-import，同时修改.babelrc:123456789&#123; "plugins": [ ["import": &#123; "libraryName": "vant", "libraryDirectory": "es", "style": true &#125;] ]&#125; 这样，build后也能够把vant tree shaking 4. 使用 Scope Hoisting scope hoisting减小代码打包后的体积，并且减少函数作用域，减小开销(目前我感觉并没有起作用。。。) new webpack.optimize.ModuleConcatenationPlugin(), 和tree shaking一样，Scope Hoisting 依赖源码时 需采用 S6 模块化语法，还需要配置mainFields 5. 使用compression-webpack-plugin开启gzip 利用该插件生成.gz文件，在服务器开启gzip的情况下，会优先返回.gz文件 以vue-cli为例： 在config/index.js中：123456// Gzip off by default as many popular static hosts such as// Surge or Netlify already gzip all static assets for you.// Before setting to `true`, make sure to:// npm install --save-dev compression-webpack-pluginproductionGzip: true,productionGzipExtensions: ['js', 'css', 'png'], //你想要gzip的文件类型 在webpack.prod.conf.js中已经有这么一段代码：123456789101112131415if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, //只处理大于此大小(10k)的资产。以byte为单位 默认为0。 minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理 。默认为0.8. &#125;) )&#125; 在build后会生成对应的.gz文件 值得注意的是并不是所有的文件都会生成对应的gzip文件，因为我们设置了threshold: 10240和minRatio: 0.8,文件大小小于10k的不会被gzip，同时只有压缩率比0.8小的资源才会被处理，否则比起直接使用没有gzip的文件，浏览器会花更多的时间用来unzip这些文件，得不偿失 未完待续···]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结一下js里操作数组的方法吧...]]></title>
    <url>%2F2018%2F07%2F05%2Farray%2F</url>
    <content type="text"><![CDATA[数组的栈方法和队列方法123456789101112131415let arr = [1,2,3,4,5];//--栈方法//push(a,b,..,z)方法在数组最后面追加一个或多个元素，返回修改后数组的长度(6)arr.push(6);//此时数组为[1,2,3,4,5,6]//pop()方法，返回并移除数组中的最后一个元素的值(6)arr.pop();//此时数组为[1,2,3,4,5]//--队列方法//shift()方法，返回并移除数组中的第一个元素的值(1)arr.shift();//此时数组为[2,3,4,5]//unshift(a,b,...,z)方法在数组最前面追加一个或多个元素，返回修改后数组的长度(5)arr.unshift(6);//此时数组为[6,2,3,4,5] 重排序方法 reverse() sort() 正是由于reverse()不够灵活，所以出现了sort()，他们均返回重新排序后的数组 操作方法 slice() //不会影响原数组 splice() //可以对数组进行删除、插入、替换，返回从原数组中删除项组成的数组,他会影响原数组 位置方法 indexOf() lastIndexOf() 返回要查找项在数组中的位置，找不到则返回-11234const arr = [1,2,3,4,5,4,3,2,1]arr.indexOf(4) //3arr.lastIndexOf(4) // 5arr.indexOf(0) // -1 数组的迭代器方法不生成新数组的迭代器方法123456789101112131415161718192021222324252627282930313233//1、forEach方法（接收一个函数作为参数）const nums = [1,2,3,4,5];nums.forEach(item =&gt; &#123; console.log(item * item)&#125;);//1，4，9，16，25//2、every方法（接收一个返回值为布尔值的函数，对数组中的每一个元素使用该函数）const evens=[2,4,6,8,10];const isAllEven = evens.every(item =&gt; &#123; return num % 2 === 0;&#125;); //当且仅当数组中的所有的元素返回为真，every函数才会返回为真//3、some方法（只要数组中有一个元素使用方法返回为真，some函数就会返回真） const nums = [1,2,3,5,7,9]; nums.some(item =&gt; &#123; return num % 2 === 0; &#125;); //true //4.reduce方法 //用法一：为数组中的元素求和 function add (currentTotal,currentValue) &#123; return currentTotal+currentValue; &#125; const nums = [1,2,3,4,5]; nums.reduce(add);//15 //用法二：将数组中的元素连接成一个长的字符串 function linkStr (foreStr,currentStr) &#123; return foreStr + currentStr; &#125; const strings = [&quot;xietian&quot;,&quot;is&quot;,&quot;studying&quot;,&quot;javascript&quot;]; strings.reduce(linkStr); 生成新数组的迭代器方法123456789101112131415//1.map方法（类似于不生成新数组中的forEach方法） //取数组中每个单词的第一个字母 const words = [&quot;xietian&quot;,&quot;is&quot;,&quot;studying&quot;,&quot;javascript&quot;]; const firstAlphas = words.map(item =&gt; &#123; return word[0].toUpperCase(); &#125;); firstAlphas.join(&quot;&quot;); //使用join可以去掉连接数组元素的逗号 //2.filter方法（类似于every方法） //筛选出符合条件（即返回值为true）的元素 const nums=[1,2,4,6,8,10]; const evens = nums.filter(item =&gt; &#123; return num % 2 === 0; &#125;); 归并方法 reduce() //从数组的第一项开始遍历 reduceRight() //从数组的最后一项开始遍历 两个方法都会迭代数组的每一项，构建一个最终的返回值 未完待续···]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生Javascript实现全屏滚动效果]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[原理原理很简单: 通过js设置外层div wrapper(#wrap)的高度为浏览器可视区的高度，并设置overflow:hidden; 设置内层div wrapper(#main)为position:relative，然后通过滚轮事件改变其top值。 HTML结构首先，HTML结构应该满足下面要求 12345678&lt;div id="wrap"&gt; &lt;div id="main"&gt; &lt;div class="page page1"&gt;1&lt;/div&gt; &lt;div class="page page2"&gt;2&lt;/div&gt; &lt;div class="page page3"&gt;3&lt;/div&gt; &lt;div class="page page4"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324#wrap &#123; overflow: hidden;&#125;#main &#123; position: relative; transition: all 1000ms ease;&#125;#page1 &#123; background: #E4E6CE;&#125;#page2 &#123; background: #6CE26C;&#125;#page3 &#123; background: #BF4938;&#125;#page4 &#123; background: #2932E1;&#125; 滚轮事件12345678910111213141516171819202122232425262728293031323334353637383940414243var pages = document.getElementsByClassName("page");var wrap = document.getElementById("wrap");var main = document.getElementById("main");var len = document.documentElement.clientHeight;wrap.style.height = len + "px";for (var i = 0; i &lt; pages.length; i++) &#123; pages[i].style.height = len + "px";&#125; if (navigator.userAgent.toLowerCase().indexOf("firefox") != -1) &#123;//火狐 document.addEventListener("DOMMouseScroll", scrollFun); &#125; else if (document.addEventListener) &#123; document.addEventListener("mousewheel", scrollFun, false); &#125; else if (document.attachEvent) &#123;//IE document.attachEvent("onmousewheel", scrollFun); &#125; else &#123; document.onmousewheel = scrollFun; &#125; var startTime = 0; var endTime = 0; var now = 0; function scrollFun(e) &#123; startTime = new Date().getTime(); var event = e || window.event; var dir = event.detail || -event.wheelDelta; // &gt;0 向下滚动 //1s内只能滚动一屏 if (startTime - endTime &gt; 1000) &#123; console.log(startTime - endTime) if (dir &gt; 0 &amp;&amp; now &gt; -3 * len) &#123; now -= len; main.style.top = now + "px"; endTime = new Date().getTime(); &#125; else if (dir &lt; 0 &amp;&amp; now &lt; 0) &#123; now += len; main.style.top = now + "px"; endTime = new Date().getTime(); &#125; &#125; else &#123; console.log(startTime - endTime) event.preventDefault(); &#125; &#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>fullpage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue服务端渲染]]></title>
    <url>%2F2018%2F05%2F20%2Fvue-ssr%2F</url>
    <content type="text"><![CDATA[前言鉴于SPA的明显的缺点：首屏白屏时间较长以及SEO不友好，因此在上述需求下，SSR十分有必要。 注意事项 由于用例和平台 API 的差异，当运行在不同环境中时，我们的代码将不会完全相同 服务器上的数据响应 在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。 因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据(“pre-fetching” data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。 组件生命周期钩子函数 由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。 此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。 访问特定平台(Platform-Specific) API 通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。 对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，axios 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。 对于仅浏览器可用的 API，通常方式是，在「纯客户端(client-only)」的生命周期钩子函数中惰性访问(lazily access)它们。 自定义指令大多数自定义指令直接操作DOM，因此会在服务器端渲染(SSR)过程中导致错误。有两种方法可以解决这个问题： 推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。 如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 directives 选项所提供”服务器端版本(server-side version)”。 Let’s go搭建脚手架12// 利用webpack-simple搭建一个简单的脚手架vue init webpack-simple vue-ssr src目录可能需要像下面这样： 12345678910src├── components│ ├── Foo.vue│ ├── Bar.vue│ └── Baz.vue├── index.template.html # SSR模板├── App.vue├── app.js # 通用 entry(universal entry)├── entry-client.js # 仅运行于浏览器└── entry-server.js # 仅运行于服务器 客户端与服务端通用入口：app.js123456789101112import Vue from 'vue'import App from './App.vue'// 导出一个工厂函数，用于创建新的// 应用程序、router 和 store 实例export function createApp () &#123; const app = new Vue(&#123; // 根实例简单的渲染应用程序组件。 render: h =&gt; h(App) &#125;) return &#123; app &#125;&#125; 客户端入口：entry-client.js 客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中 1234567import &#123; createApp &#125; from './app'const &#123; app &#125; = createApp()// 这里假定 App.vue 模板中根元素具有 `id="app"`app.$mount('#app') 服务端入口：entry-server.js 服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配(server-side route matching)和数据预取逻辑(data pre-fetching logic) 123456import &#123; createApp &#125; from './app'export default context =&gt; &#123; const &#123; app &#125; = createApp() return app&#125; 构建配置（webpack）建议将配置分为三个文件： webpack.base.config.js: 包含在两个环境共享的配置，例如，输出路径(output path)，别名(alias)和 loader。 webpack.client.config.js webpack.server.config.js webpack.client.config.js和webpack.server.config.js，可以通过使用 webpack-merge 来简单地扩展webpack.base.config.js webpack.base.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var path = require('path')var webpack = require('webpack')module.exports = &#123; output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'vue-style-loader', 'css-loader' ], &#125;, &#123; test: /\.scss$/, use: [ 'vue-style-loader', 'css-loader', 'sass-loader' ], &#125;, &#123; test: /\.sass$/, use: [ 'vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax' ], &#125;, &#123; test: /\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; // Since sass-loader (weirdly) has SCSS as its default parse mode, we map // the "scss" and "sass" values for the lang attribute to the right configs here. // other preprocessors should work out of the box, no loader config like this necessary. 'scss': [ 'vue-style-loader', 'css-loader', 'sass-loader' ], 'sass': [ 'vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax' ] &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125;, extensions: ['*', '.js', '.vue', '.json'] &#125;, devServer: &#123; historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; webpack.client.config.js 如果你使用 CommonsChunkPlugin(webpack4使用splitChunkPlugin)，请确保仅在客户端配置(client config)中使用，因为服务器包需要单独的入口 chunk1234567891011121314151617181920212223const webpack = require('webpack')const merge = require('webpack-merge')const baseConfig = require('./webpack.base.config.js')const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')module.exports = merge(baseConfig, &#123; entry: './src/entry-client.js', output: &#123; filename: '[name].client.js' &#125;, plugins: [ // 重要信息：这将 webpack 运行时分离到一个引导 chunk 中， // 以便可以在之后正确注入异步 chunk。 // 这也为你的 应用程序/vendor 代码提供了更好的缓存。 new webpack.optimize.CommonsChunkPlugin(&#123; name: "manifest", minChunks: Infinity &#125;), // 此插件在输出目录中 // 生成 `vue-ssr-client-manifest.json`。 // new VueSSRClientPlugin() ]&#125;) webpack.client.config.js12345678910111213141516171819202122232425262728293031323334353637383940const merge = require('webpack-merge')const nodeExternals = require('webpack-node-externals')const baseConfig = require('./webpack.base.config.js')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')module.exports = merge(baseConfig, &#123; // 将 entry 指向应用程序的 server entry 文件 entry: '/path/to/entry-server.js', // 这允许 webpack 以 Node 适用方式(Node-appropriate fashion)处理动态导入(dynamic import)， // 并且还会在编译 Vue 组件时， // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。 target: 'node', // 对 bundle renderer 提供 source map 支持 devtool: 'source-map', // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports) output: &#123; libraryTarget: 'commonjs2' &#125;, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应用程序依赖模块。可以使服务器构建速度更快， // 并生成较小的 bundle 文件。 externals: nodeExternals(&#123; // 不要外置化 webpack 需要处理的依赖模块。 // 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件， // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单 whitelist: /\.css$/ &#125;), // 这是将服务器的整个输出 // 构建为单个 JSON 文件的插件。 // 默认文件名为 `vue-ssr-server-bundle.json` plugins: [ // new VueSSRServerPlugin() ]&#125;) 打包1.执行以下命令：12//生成客户端打包文件webpack --config ./build/webpack.client.config.js 会在dist目录下生成： main.client.js manifest.client.js 2.执行以下命令：12//生成服务端打包文件webpack --config ./build/webpack.server.config.js 会在dist目录下生成： main.server.js 修改server.js12345678910111213141516171819202122232425262728293031323334353637383940const Vue = require('vue')const express = require('express')const server = express()const renderer = require('vue-server-renderer').createRenderer(&#123; template: require('fs').readFileSync('./src/index.template.html', 'utf-8')&#125;)// const createApp = require('./src/app.js')// 通过服务端打包文件main.server.js来创建app实例const createApp = require('./dist/main.server.js').default// 将dist文件夹作为静态资源目录server.use('/dist', express.static('./dist'))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', meta: ` &lt;meta charset="utf-8"&gt; `, url: req.url &#125; // const app = new Vue(&#123; // data: &#123; // url: req.url // &#125;, // template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;` // &#125;) // 不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例 const app = createApp(context) renderer.renderToString(app, context).then(html =&gt; &#123; res.end(html) &#125;).catch(e =&gt; &#123; res.status(500).end('Internal Server Error') &#125;)&#125;)server.listen(8081) index.template.html中引入client端打包文件123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt; &#123;&#123;&#123;meta&#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;script src="/dist/manifest.client.js"&gt;&lt;/script&gt; &lt;script src="/dist/main.client.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行以下命令：12node server# supervisor server 就可以成功访问到vue欢迎页面了 路由和代码分割在src目录下创建router.js1234567891011121314151617import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)export function createRouter () &#123; return new Router(&#123; mode: 'history', routes: [ &#123; path: '/hello/:id', // 动态导入组件，需要安装babel-preset-stage-2 component: () =&gt; import('./components/hello') &#125; ] &#125;)&#125; 修改通用入口app.js1234567891011121314151617import Vue from 'vue'import App from './App.vue'import &#123;createRouter&#125; from './router'// 导出一个工厂函数，用于创建新的// 应用程序、router 和 store 实例export function createApp () &#123; const app = new Vue(&#123; // 根实例简单的渲染应用程序组件。 render: h =&gt; h(App), router &#125;) const router = createRouter() return &#123; app, router &#125;&#125; 修改entry-client.js12345//挂载 app 之前调用 router.onReady//因为路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 在 entry-server.js 中实现服务器端路由逻辑123456789101112131415161718192021222324import &#123; createApp &#125; from './app'export default context =&gt; &#123; // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise， // 以便服务器能够等待所有的内容在渲染前就已经准备就绪。 return new Promise((resolve, reject) =&gt; &#123; const &#123; app, router &#125; = createApp() // 设置服务器端 router 的位置 router.push(context.url) // 等到 router 将可能的异步组件和钩子函数解析完 router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() // 匹配不到的路由，执行 reject 函数，并返回 404 if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // Promise 应该 resolve 应用程序实例，以便它可以渲染 resolve(app) &#125;, reject) &#125;)&#125; 修改server.js12345678910111213141516171819202122232425262728293031server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', meta: ` &lt;meta charset="utf-8"&gt; `, url: req.url &#125; // const app = createApp(context) // renderer.renderToString(app, context).then(html =&gt; &#123; // res.end(html) // &#125;).catch(e =&gt; &#123; // res.status(500).end('Internal Server Error') // &#125;) createApp(context).then(app =&gt; &#123; renderer.renderToString(app, (err, html) =&gt; &#123; if (err) &#123; if (err.code === 404) &#123; res.status(404).end('Page not found') &#125; else &#123; res.status(500).end('Internal Server Error') &#125; &#125; else &#123; res.end(html) &#125; &#125;) &#125;)&#125;) 再次打包1.执行以下命令：12//生成客户端打包文件webpack --config ./build/webpack.client.config.js 会在dist目录下生成： 0.client.js main.client.js manifest.client.js 2.执行以下命令：12//生成服务端打包文件webpack --config ./build/webpack.server.config.js 会在dist目录下生成： 0.server.js main.server.js 上面的0.client.js和0.server.js就是动态加载的组件hello.vue所打包出来的文件，这样就可以按需引用 总结上面的代码只是完成了很小的一部分，真正想要投入到生产工作量比这个大太多，因此如果不是必要，推荐使用现有的服务端渲染框架：next.js/nuxt.jsd等。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F04%2F22%2Fjs-sort%2F</url>
    <content type="text"><![CDATA[一、前言本文整理了几种js排序方法 sort() 快速排序 冒泡排序 二、sort()利用sort function 可以完成一些简单的数组排序 对数组排序1234567var arr = [3,55,7];arr.sort();arr.sort(function(a,b) &#123; return a - b;&#125;);console.log(arr);//输出结果[3,7,55] 根据数组对象的某一属性排序123456789101112131415var arr= [ &#123; 'rank': 2&#125;, &#123; 'rank': 1&#125;, &#123; 'rank': 5&#125;, &#123; 'rank': 6&#125;];arr.sort(function(a, b) &#123; return a.rank - b.rank;&#125;);console.log(arr);//输出结果&#123; 'rank': 1&#125;,&#123; 'rank': 2&#125;,&#123; 'rank': 5&#125;,&#123; 'rank': 6&#125; 三、快速排序1234567891011121314151617function quickSort(arr) &#123; let len = arr.length if(len &lt;= 1) &#123; return arr &#125; let i = Math.floor(len / 2) let num = arr.splice(i, 1) let left = [], right = [] for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; num) &#123; left.push(arr[i]) &#125;else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(num, quickSort(right))&#125;console.log(quickSort([1,11,2,2,6]))//[1,2,2,6,11] 可以看出，虽然排序是正确的，但是无法取出重复元素2，要实现去重的话用ES6的Set数据结构可以方便的做到： 1234const arr = [1,11,2,2,6]const newArr = [...new Set(arr)]//or//const newArr = Array.from(new Set(arr)) 四、冒泡排序 利用双层循环来逐个比较数组的每个值 12345678910111213141516171819function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for(let j = i + 1; j &lt; arr.length; j++) &#123; //let n = 0 //if(arr[i] &gt; arr[j]) &#123; //n = arr[i] //arr[i] = arr[j] //arr[j] = n //&#125; //有了ES6的结构赋值，交换数值只要一句话 if(arr[i] &gt; arr[j]) &#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; &#125; &#125; return arr&#125;console.log(bubbleSort([1,11,2,7]))//[1,2,7,11]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做一个自定义滚动条]]></title>
    <url>%2F2018%2F03%2F17%2Fv-custom%2F</url>
    <content type="text"><![CDATA[一、前言最近在做的项目需要用到自定义滚动条，既然时间充裕，就自己做了个。我将其做成了Vue的全局自定义指令，只要满足对应的HTML结构就可以在任意地方调用，相对来说也是很方便的。 二、原理（以下默认内容高度超出容器高度。） 2.1 结构需要满足以下HTML结构： 12345678910&lt;div class="wrapper"&gt; &lt;div class="content-wrapper" v-mousewheel&gt; &lt;div class="content"&gt; &lt;!--滚动内容--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="scroll-bar"&gt; &lt;div class="scroll-block" v-scrollY&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.2原理 通过拖拽事件和滚轮事件动态改变内容区域的top值 因此需要: 设置容器content-wrapper属性：overflow: hidden; 设置内容content属性：position: absolute; 这样，基础工作就已经ok了，开始写交互事件。 三、代码3.1 拖拽事件大的方向上没什么问题，但是需要注意的是，拖动滑块时如果不做处理，会出现抖动现象，这是因为拖动时onmousemove事件频繁触发导致，因此加入防抖功能即可： 加个定时器，每次执行onmousemove时清除定时器防止多次触发，定时器事件设置为20ms是因为浏览器的最大刷新频率为16.7ms/次。 这样，在滑块scroll-block上加一个自定义指令v-scrollY,就可以实现拖拽效果啦~ 12345678910111213141516171819202122232425262728Vue.directive('scrollY', &#123; bind (el, binding) &#123; let $el = el $el.onmousedown = function(e) &#123; let disY = e.clientY - $el.offsetTop let $content = $el.parentNode.parentNode.firstChild let contentH = $content.clientHeight document.onmousemove = function(e) &#123; clearTimeout(timer) let timer = setTimeout(() =&gt; &#123; // 滚动滑块滚动距离 let top = Math.min(Math.max(e.clientY - disY, 0), 306) // 内容区域滚动距离 let topC = top * (contentH - 600) / 306 $el.style.top = top + 'px' $content.style.top = -topC +'px' &#125;, 20) $el.style.backgroundColor = '#acaaaa' &#125; document.onmouseup = function(e) &#123; document.onmousemove = null document.onmouseup =null $el.style.backgroundColor = '#e9e9e9' &#125; &#125; &#125;&#125;) 3.2 滚轮事件滚轮事件相对来说比较麻烦，这是因为：firefox和其他浏览器的滚轮事件不一样。 在firefox中是DOMMouseScroll ,其他浏览器中则是mousewheel 在firefox中通过e.detail的正负值来判断上下滚动，其他浏览器中则是通过e.wheelDetla来判断上下滚动 - firefox 其它浏览器 上滚 e.detail &lt; 0 e.wheelDetla &gt; 0 下滚 e.detail &gt; 0 e.wheelDetla &lt; 0 其它有几点值得说一下： 滚动时需要阻值默认事件，防止在子滚动区滚动时使父滚动区跟着滚动； 滚动区内容设置：user-select: none;因为我发现在拖拽的时候鼠标离开滚动滑块会选中滚动内容区文字。 注意上面几点应该就没问题了，然后在容器content-wrapper上添加v-mousewheel就可以滚动啦～123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.directive('mousewheel', &#123; bind( el, biding ) &#123; let num = 0 let $el = el function addEvent(obj, type, fn, capture) &#123; if (obj.addEventListener) &#123; if( !capture ) &#123;capture = false&#125; obj.addEventListener(type, fn, capture) &#125; else if (obj.attachEvent) &#123; obj.attachEvent("on" + type, fn) &#125; &#125; function scrollDown() &#123; let $block = $el.parentNode.children[1].children[0] let dis = Math.min(20 * (num--), $el.clientHeight - 600) $el.style.top = Math.min(0, -dis) + 'px' let topB = Math.max(0, dis) * 306 / ($el.clientHeight - 600) $block.style.top = topB + 'px' &#125; function scrollUp() &#123; let $block = $el.parentNode.children[1].children[0] let dis = Math.min(20 * (num++), $el.clientHeight - 600) $el.style.top = Math.min(0, -dis) + 'px' let topB = Math.min(0, -dis) * 306 / ($el.clientHeight - 600) $block.style.top = -topB + 'px' &#125; function customScroll(e) &#123; if( e.wheelDelta ) &#123; if (e.wheelDelta &gt; 0) &#123; //下滚 scrollDown() &#125; else &#123; //上滚 scrollUp() &#125; &#125;else if ( e.detail ) &#123; //兼容火狐 if (e.detail &lt; 0) &#123; //下滚 scrollDown() &#125; else &#123; //上滚 scrollUp() &#125; &#125; &#125; addEvent($el, 'mousewheel', (e) =&gt; &#123; let ev = e || window.event ev.preventDefault ? ev.preventDefault() : ev.returnvalue = false customScroll(e) &#125;) // 兼容firefox addEvent($el, 'DOMMouseScroll', (e) =&gt; &#123; let ev = e || window.event ev.preventDefault ? ev.preventDefault() : ev.returnvalue = false customScroll(e) &#125;) &#125;&#125;) 四、小结考虑到滚轮事件在不同浏览器中的表现不同，处理好兼容性的问题是至关重要的。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>自定义滚动条</tag>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise之不完全解读]]></title>
    <url>%2F2018%2F03%2F07%2Fpromise%2F</url>
    <content type="text"><![CDATA[一、前言1.什么是promise？ 2.promise有什么用？ 3.什么时候用promise？ MDN的官方解释是： Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值 新学一个新的概念的时候光从字面上其实无法很好的理解其含义，总之让我们带着这三个问题，一步步抽丝剥茧，道出它的真面目 所谓promise，翻译成中文就是：许诺、承诺的意思，表示一种将来的状态。 它在异步计算中扮演者重要的角色：它可以将异步操作队列化，按照我们想要的顺序进行执行，并且返回符合预期的结果 我们可以在对象之间传递和操作promise，帮助我们处理队列 二、历史如果了解JavaScript的历史，可能会帮助我们更好的认识promise。 为检查表单而生的JavaScript 在JavaScript出现以前，用户在填写表单时稍有不慎就得重新填写一遍，毫无用户体验。这时就出现了JavaScript，他天生就是用来检查表单的。那么作为一门浏览器端的语言，就注定了它异步的命运：它的执行不能使页面冻结。 其实在JavaScript里面异步的问题还不是特别严重，因为JavaScript里的异步主要以DOM操作为主，但是自从出现了Nodejs以后，它对异步的依赖进一步加剧。 三、promise的基本概念使用promise的基本方法：12345678910111213new Promise( (resolve, reject) =&gt; &#123; resolve() //or reject()&#125; ).then(//可以返回一个新的promise对象//可以返回一个同步的值//可以抛出一个同步的异常).catch(//捕获错误) promise有三种状态： pending：进行中 fulfilled：成功 rejected：失败 而且一旦其状态变为fulfill或reject，就不可继续改变状态 promise通过引入仅仅一个回调函数来避免所谓的回调地狱，也就是说，在.then()里面不应该出现新的回调。正确的做法是：返回一个新的promise对象来实现.then()的链式调用。 四、promise陷阱（promise穿透）纸上得来终觉浅，直接上代码吧： 1234567891011121314151617181920212223//在promise里面不返回任何值或者返回false，会有什么结果？console.log('1');new Promise(resolve =&gt; &#123; setTimeout( () =&gt; &#123; resolve('2'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log(value); console.log('3'); (function () &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log('4'); resolve('5'); &#125;, 2000); &#125;); &#125;()); return false; &#125;) .then( value =&gt; &#123; console.log(value + '6'); &#125;); 执行顺序：1-2-3-false6-4 解释：在promise里面不返回任何值或者返回false，他会立刻往下执行。同理，如果去掉return false,结果就是 1-2-3-undefined6-4 （注意：那个立即执行函数由于不再.then()的直接回调里面，因此它与.then()的回调不处于同一执行栈） 写出简洁的promise 1234new Promise( (resolve, reject) =&gt; &#123; resolve(something)&#125;).then(/*```*/) 其实写成下面这种方式更加好看 1Promise.resolve(something).then(/*```*/) 那么，我们再来看一个例子： 12345Promise.resolve('foo').then(Promise.resolve('bar')).then((res) =&gt; &#123; consoe.log(res) // foo&#125;) 结果居然不是‘bar’而是‘foo’，实际上这和前面的例子很相似，如果给.then()传递的不是一个函数，它回直接解析为.then(null)，导致立即执行下一个.then(),发生所谓的promise穿透 如果想要得到‘bar’,可以这么写： 1234567Promise.resolve('foo').then( () =&gt; &#123; return Promise.resolve('bar')&#125;).then( (res) =&gt; &#123; consoe.log(res) // bar&#125;) 最后，推荐这篇文章：we have a problem with promises]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
      </tags>
  </entry>
</search>
