<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript函数柯里化]]></title>
    <url>%2F2019%2F05%2F31%2Fcurry%2F</url>
    <content type="text"><![CDATA[Function Apply在一些存粹的函数式编程语言中，函数并不是被描述为called或invoked，而是描述为applied。在js里面，通过Function.prototype.apply()可以实现Function Apply。 下面是一个函数应用的例子： 1234567function say(s) &#123; return "Hello" + s;&#125;//调用函数say("world");//应用函数say.apply(null, ["world"]) 在上面的例子中，invoking和applying可以得到相同的结果。apply()接受两个参数：第一个参数为将要绑定到该函数体内this的一个对象，第二个参数为一个数组。如果第一个参数为空，那么this指向全局。 除了apply()以外，还有call()方法，它仅仅只是apply()的语法糖。当函数仅有一个参数时，推荐使用call代替apply，因为可以避免创建只有一个元素的数组，减小内存开销。 为了达到最佳新能，Node的Event模块就在三个参数以下用call否则用apply （我写了一篇文章，如何从0实现call/apply） Currycurry化就是将完全应用函数变为部分应用函数的过程（简单来说就是通过改变传递给函数参数的个数来达到改变函数返回结果） 先举个简单点的🌰： 12345678910111213function add(x, y) &#123; //部分应用 if(typeof y === "undefined") &#123; return function(y) &#123; return x + y &#125; &#125; //完全应用 return x + y&#125;add(1)(2) // 3（部分应用）add(1, 2) // 3（完全应用） 上面的代码比较容易理解：如果同时传递x和y，会走直接return x+y；但如果只传一个x，那会返回一个新的函数，并将之前传递的x保存起来供下次函数应用 然后实现一个通用的curry函数：12345678910111213141516function curry(fn) &#123; const slice = Array.prototype.slice; let savedArgs = slice.call(arguments, 1);//剔除第一个参数（fn）, 将类数组对象转化为数组 return function() &#123; let newArgs = slice.call(arguments); let args = [...savedArgs, ...newArgs]; return fn.apply(null, rags); &#125;&#125;//定义一个普通函数function add(x, y, z) &#123; return x + y + z&#125;//curry化curry(add, 1)(2, 3) // 6 何时使用Curry化当正在调用同一个函数，并且传递的参数大多都是相同的，那么该函数可能是用于curry化的一个很好的候选参数。可以通过将一个函数集合部分应用到函数中，从而动态创建一个新函数。 举个简单的🌰：12345678910111213141516171819202122function curry(func, args = []) &#123; let arity = func.length; return function (..._args) &#123; _args.unshift(...args); if(_args.length &lt; arity) &#123; return curry.call(null, func, _args); &#125; return func(..._args); &#125;&#125;function checkFun(reg, str) &#123; return reg.test(str);&#125;let check = curry(checkFun);let checkPhone = check(/^1[34578]\d&#123;9&#125;$/);console.log(checkPhone('13997603799')) //truelet checkEmail = check(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);console.log(checkEmail('839862975@qq.com')) //true 在vue源码里面也有大量函数curry化的应用。比如vue在将VNode进行patch生成真实DOM的过程中，为了抹平平台差异（web和weex），将平台差异化的参数提前固化，这样不用每次调用patch方法的时候都传递nodeOps和modules了 nodeOps 表示对 “平台 DOM” 的一些操作方法，modules 表示平台的一些模块，它们会在整个 patch 过程的不同阶段执行相应的钩子函数1234567891011//plantforms/web/runtime/patch.jsimport * as nodeOps from 'web/runtime/node-ops'import &#123; createPatchFunction &#125; from 'core/vdom/patch'import baseModules from 'core/vdom/modules/index'import platformModules from 'web/runtime/modules/index'// the directive module should be applied last, after all// built-in modules have been applied.const modules = platformModules.concat(baseModules)export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写一个webpack plugin吧]]></title>
    <url>%2F2019%2F05%2F24%2Fwebpack-plugin%2F</url>
    <content type="text"><![CDATA[什么是plugin？webpack在运行过程中会广播许多事件，plugin可以监听这些事件，以在一定的时机去执行一些事情去改变输出结果。 copyright-webpack-plugin先写个简单的plugin，有个直观的印象后再具体介绍相关内容。 这个plugin会在webpack打包输出资源到目标文件夹之前生成一个copyright.txt文件 1234567891011121314151617181920212223// plugins/copyright-webpack-plugin.jsclass CopyrightWebpackPlugin &#123; constructor(options) &#123; this.content = options.content &#125; apply(compiler) &#123; compiler.hooks.compile.tap('CopyrightWebpackPlugin', (compilation) =&gt; &#123; console.log('compile') &#125;) compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (compilation, cb) =&gt; &#123; // compilation: 本次打包的内容 // compilation.assets： 本次打包生成的文件 // debugger compilation.assets['copyright.txt'] = &#123; source: () =&gt; this.content, size: () =&gt; this.content.length &#125; cb() &#125;) &#125;&#125;module.exports = CopyrightWebpackPlugin 使用：12345678910// webpack.config.jsconst CopyrightWebpackPlugin = require(&apos;./plugins/copyright-webpack-plugin&apos;)module.exports = &#123; plugins: [ new CopyrightWebpackPlugin(&#123; content: &apos;Copyright by xietian&apos; &#125;) ]&#125; Webpack 启动后，在读取配置的过程中会先执行 new CopyrightWebpackPlugin(options），初始化 CopyrightWebpackPlugin 并获得其实例。 在初始化 compiler 对象后，再调用 CopyrightWebpackPlugin.apply (compiler）为插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.hooks.eventName.tap（插件名称，回调函数）监听到 Webpack 广播的事件，并且可以通过 compiler 对象去操作 Webpack compiler和compilation在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation ，它们是 Plugin 和 Webpack之间的桥梁。Compiler 和 Compilation 的含义如下: Compiler 对象包含了 Webpack 环境的所有配置信息，包含 options loaders plugins等信息。这个对象在Webpack启动时被实例化，它是全局唯一的，可以简单地将它理解为 Webpack 实例 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack以开发模式运行时，每当检测到一个文件发生变化，便有一次新的 Compilation创建。Compilation 对象也提供了很多事件回调供插件进行扩展。通过 Compilation也能读取到 Compiler 对象。 Compiler 和 Compilation都继承自Tapable ++Compiler Compilation 的区别在于： Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只代表一次新的编译++。 Plugin API这里只介绍一些常用的Plugin ApI 读取输出资源、代码块、模块及其依赖emit hook表示资源编译完毕，生成资源到 output 目录之前，在这里可以修改输出内容12345678910111213141516171819class Plugin &#123; apply(compiler) &#123; compiler.hooks.emit.tapAsync('Plugin', (compilation, cb) =&gt; &#123; // compilation.chunks是一个数组，用于存放所有代码块 cimpilation.chunks.forEach(chunk =&gt; &#123; // 一个代码块由多个模块组成，chunk.forEachModule遍历其中的模块 chunk.forEachModule(module =&gt; &#123; // module.fileDependencies是一个数组, 存放当前模块的所有依赖的文件路径 module.fileDependencies.forEach(filePath =&gt; &#123;&#125;) &#125;) // Webpack会根据Chunk生成输出的文件资源，每个 Chunk 都对应 一个及以上的输出文件, 例如在 Chunk 中包含 css 模块并且使用了 ExtractTextPlugin 时，该 Chunk 就会生成 js/css两个文件 &#125;) &#125;) &#125;&#125; 监听文件变化Webpack 会从配置的入口模块出发，依次找出所有依赖模块， 当入口模块或者其依赖的模块发生变化时 就会触发一次新的 Compilation watchRun hook: 一个新的编译(compilation)触发之后，执行一个插件，但是是在实际编译开始之前 待续…]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个webpack loader吧]]></title>
    <url>%2F2019%2F05%2F23%2Floader%2F</url>
    <content type="text"><![CDATA[什么是loader？Loader可以理解为模块转换器，作用是将原内容按照一定的规则生成新内容 以处理.scss文件为例： 将.scss文件交给scss-loader处理，转化为.css文件 将.css文件交给css-loader处理，找出其中依赖的资源，压缩css等 将css-loader输出的css交给style-loader处理，转换成通过脚本加载的js代码 对应webpack配置如下：12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ &#123; test: /\.scss/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; minimize: true &#125; &#125;, &#123; loader: 'scss-loader' &#125; ] &#125; ] &#125;&#125; 由此可以发现loader的责任是单一的：一个loader只负责做一件事情，通过链式调用的方式来达到我们处理文件的目的。我们自己在编写loader的时候也需要遵循这一原则。 loader的本质webpack运行于node.js之上，一个loader本质上就是一个node.js模块，这个模块通过module.exports导出一个函数，原内容为该函数的参数，通过处理后返回新内容 loader API loader API用于webpack和loader之间进行通信（loader API 文档） 接下来我会对常用的loader api进行解释 1. 获取loader的options1234567const loaderUtils = require('loader-utils')module.exports = function(source) &#123; // 以上面的css-loader为例, // 这里的options: &#123; minimize: true &#125; const options = loaderUtils.getOptions(this) return source&#125; 2. 返回其它结果上面的例子未将内容处理就返回了，在某些时候我们可能需要返回一些额外的信息，比如sourceMap。 以babel-loader转化es6语法为例，它还需要输出转化成es5语法后对应的sourceMap，以便于调试代码：123module.exports = function(source) &#123; this.callback(null, source, sourceMap)&#125; 没错，这里的关键就是callback api，它的详细使用如下：123456this.callback( err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any); 关于sourceMap： 一般只在开发环境下生成，因为生成sourceMap十分耗时，生产环境关闭sourceMap以加速构建速度。this.sourceMapAPI告诉loader在当前构建环境是否需要sourceMap。如果我们编写的loader会生成SourcMap，请铭记这一点 3. 同步与异步前面的示例都是同步的，如果我们要在loader中进行异步操作，那么需要使用this.asyncAPI123456module.exports = function(source) &#123; const callback = this.async() settimeout(() =&gt; &#123; callback(null, source, sourceMap) &#125;)&#125; 4. 处理二进制数据在默认情况下， Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。但在某些场景下 Loader 不会处理文本文件，而会处理二进制文件如 file-loader ，这时就需要 Wepack为Loader传入二进制格式的数据。为此，我们需要这样编写 Loader:123456module.exports = function(source) &#123; console.log(source instanceof Buffer) // true&#125;// 这行代码使loader获取的source为二进制数据module.exports.raw = true 暂时只介绍这几个api，查看官方文档了解更多吧。 本地loader的使用在开发过程中，我们需要本地加载loader而不是把loader传到npm再使用。如何做到以loader: &#39;xxx-loader&#39;的形式使用而不是loader: path.resolve(__dirname, &#39;./loaders/xxx-loader&#39;)，这时候就需要resolveLoader选项了，它告诉webpack怎么去查找loader：123456module.exports = &#123; resolveLoader: &#123; // 在哪里查找loader，有先后顺序 modules: ['node_modules', './loaders'] &#125;&#125; 当然，除了上面的方式，通过npm link将本地loader目录建立一个软连接到node_modules，也可以达到相同的目的。 loader的应用场景根据上面所说的，我们假设有这样一个需求：在现有业务下加上一套错误监控与处理机制。我们可以尝试编写这样一个loader，为相应的代码块外面加上try…catch，这样在不修改原有代码的基础上还能实现我们的需求，简直再合适不过了。]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于rust构建一个wasm模块并且发布到npm]]></title>
    <url>%2F2019%2F05%2F22%2Frust-wasm%2F</url>
    <content type="text"><![CDATA[目的本文试图基于rust构建一个wasm模块并且发布到npm！ 工具 在这之前，我们需要安装好必要的工具 [x] 安装rust 这步不多说了，安装后在终端输入rustc --version如果出现以下提示说明安装成功: 1rustc 1.34.1 (fc50f328b 2019-04-24) 安装rust的同时也会默认安装cargo，这是rust官方的包管理工具，类似node中的npm [x] 安装wasm-pack 它会帮助我们把我们的代码编译成 WebAssembly 并制造出正确的 npm 包 1cargo install wasm-pack 新建项目1cargo new --lib hello_wasm 执行上面命令会创建一个新项目，目录结构很简单：123-- Cargo.toml-- src -- lib.rs Cargo.toml就是项目配置文件，我们需要增加一些配置：12345[lib]crate-type = ["cdylib"][dependencies]wasm-bindgen = "0.2" 我们需要依赖wasm-bindgen，并且指定了版本号（0.2.x） 同时指定了crate-type=[&quot;cdylib&quot;],意思是编译成一个可以被其它语言加载的动态库。 查看官方文档 写点代码在src/lib.rs下：123456789101112131415extern crate wasm_bindgen;use wasm_bindgen::prelude::*;// 告诉rust需要导入的js函数，这里我们拿到了window.alert#[wasm_bindgen]extern &#123; pub fn alert(s: &amp;str);&#125;// 导出可以被js调用的函数greet()#[wasm_bindgen]pub fn greet(name: &amp;str) &#123; alert(&amp;format!("Hello, &#123;&#125;", name));&#125; 构建包1wasm-pack build --scope my_npm_username 运行wasm-pack build帮我们做了一系列的事情： 将rust编译成WebAssembly 在生成的WebAssembly上运行wasm-bindgen, 从而产生一个包装了WebAssembly的npm模块 创建了一个pkg文件夹，里面包含了生成的.wasm和.js文件 根据Cargo.toml在pkg下生成对应的package.json文件 拷贝 README.md (如果存在) 到pkg下 发布包到npm123cd pkgnpm publish . 到这步以后，我们就可以在npm上看到刚刚发布的包了，如果你在build的时候指定了scope, 那么包名就是@my_npm_username/hello_wasm 使用包 新建一个前端工程 12345678910111213141516171819&#123; "name": "wasm-test", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "dev": "webpack-dev-server" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "@tian0o0/hello_wasm": "^0.1.0" &#125;, "devDependencies": &#123; "webpack": "^4.31.0", "webpack-cli": "^3.3.2", "webpack-dev-server": "^3.3.1" &#125;&#125; 12345678910// webpack.config.jsconst path = require('path');module.exports = &#123; entry: "./index.js", output: &#123; path: path.resolve(__dirname, "dist"), filename: "index.js", &#125;, mode: "development"&#125;; 1234567891011&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello-wasm example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234// index.jsimport("@tian0o0/hello_wasm").then(module =&gt; &#123; module.greet("world");&#125;); 前端代码写好后：12npm installnpm run dev 打开localhost:8080, 看到弹框提示Hello, world，说明已经成功了。 rust-webpack-template前面我们通过一系列操作将rust编译成wasm再发布到npm才能使用，十分不方便，还好rustwasm官方为我们提供了rust-webpack-template 1. 运行下面命令拉取模板1npm init rust-webpack your_app_name 该项目的初始结构如下：123456789101112131415├── LICENSE-APACHE├── LICENSE-MIT├── README.md├── crate│ ├── Cargo.lock│ ├── Cargo.toml│ ├── pkg│ ├── src│ └── target├── index.html├── js│ └── index.js├── package-lock.json├── package.json└── webpack.config.js 执行 npm run build将生产dist目录：12345├── dist│ ├── 1.bundle.js│ ├── 362e0215e53c5653c642.module.wasm│ ├── bundle.js│ └── index.html 执行npm start将通过webpack-dev-server开启本地服务，修改src下的rust代码，也可以获得热更新的效果，大大提高了开发效率。 总结本文所做的事情十分简单，wasm适用于需要在前端进行复杂运算的场景，希望以后能有机会在项目中实战。]]></content>
      <categories>
        <category>wasm</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>wasm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做一个chrome扩展吧]]></title>
    <url>%2F2019%2F03%2F20%2Fchrome-extension%2F</url>
    <content type="text"><![CDATA[待完成]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack优化之道]]></title>
    <url>%2F2018%2F10%2F25%2Fwebpack%2F</url>
    <content type="text"><![CDATA[优化1.缩小文件搜索范围1.1优化loader配置 由于 Loader 对文件的转换操作很耗时，所以需要让尽可能少的文件被 Loader 理。 通过test、include、exclude去确定哪些文件需要被处理123456789101112//以babel-loader为例：module.exports = &#123; module: &#123; rules: [ &#123; test: /.js$/, use: ['babel-loader?cacheDirectory'], include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; 1.2优化resolve.modules配置 resolve.modules用于配置webpack去哪些目录寻找三方模块 默认值为：[‘node_modules]。 含义是先去当前目录的 node_modules 目录下去找我们想找的模块，如果没找到 就去上一级目录./node_modules中找，再没有就去 ../../node_modules 中找，以此类推 这和 node.js 的模块寻找机制很相似。 当安装 的第三方模块都放在项目根目录的 node modules 目录下时，就没有必要按照默认 的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找12345module.exports = &#123; resolve: &#123; modules: [path.resolve(__dirname, 'node_modules')] &#125;&#125; 1.3优化resolve.mainField配置 在安装的第三方模块中都会有一个 package.json 文件，用于描述这个模块的属性其中的某些字段用于描述入口文件在哪里， resolve.mainFields用于配置采用哪个字段作为入口文件的描述 可以存在多个字段描述入口文件的原因是，某些模块可以同时用于多个环境中，针对不同的运行环境需要使用不同的代码。以 isomorphic-fetch ( https://github.corn/matthewandrews/isomorphic-fetch）为例，它是 fetch API ( https://developer.mozilla.org/zh-CN/docs/Web/APl/Fetch_API) 的一个实现，但可同时用于浏览器和 Node.js 环境 在它的 package. jsoη中就有两个入口文件描述字段：1234&#123;"browser":”fetch-npm-browserify.js”,"main":”fetch-npm-node.js ”&#125; isomo hic-fetch 在不同的运行环境下使用不同的代码，是因为 fetch API 的实现机制不样，在浏览器中通过原生的 fetch 或者 XMLHttpRequest 实现，在 Node. j 通过http 模块实现。 resolve.mainFields 的默认值和当前的 target 配置有关系，对应的关系如下。 target web 或者 webworker 时，值是［”browser ”，” module ”，”ma in ］。 target 为其他情况时，值是［ “module ”，”main ”］。 以target 等于 web 为例， Webpack 会先采用第三方模块中的 browser 宇段去寻找模块的入口 文件，如果不存在，就采用 module 字段，以此类推。为了减少搜索步骤，在明确第 方模块的入口文件描述字段时，我们可以将它设置得尽量少。 由于大多数第三方模块都采用 main 宇段去描述入口文件的位置，所以可以这样配置:12345module.exports = &#123; resolve: &#123; mainFields: ['main'] &#125;&#125; 1.4优化resolve.alias 在默认情况下， Webpack 会从入口文件./node_modules/vue/dist/vue.js开始递归解析和处理依赖的几十个文件，这会是一个很耗时的操作 通过配置 resolve. alias,可以让 Webpack 在处理 vue 时，直接使用单独、完整的 vue.esm.js 文件 ，从而跳过耗时的递归解析操作1234567module.exports = &#123; resolve: &#123; alias: &#123; 'vue$': path.resolve(__dirname, './node_modules/vue/dist/vue.runtime.esm.js') &#125; &#125;&#125; 但是，对某些库使用本优化方法后，会影响到后面要讲的使用 Tree-Sharking 去除无效代码的优化，因为打包好的完整文件中有部分代码在我们的项目中可能永远用不上。一般对整体性比较强的库采用本方法优化，因为完整文件中的代码是 个整体，每 行都是不可或缺的 但是对于 些工具类的库如 lodash ，我们的项目中可能只用到了其中几个工具函数，就不能使用本方法去优化了，因为这会导致在我们 的输出代码中包含很多永远不会被执行的代码。 1.5优化resolve.extensions例如：1extensions :[’ .js ’,’.json ’] 也就是说，当遇到 require ( ‘. /data ’） 这样的导入语句 webpack 会先去寻找.／ data.js 文件，如果该文件不存在，就去寻找 data.json 文件，如果还是找不到就报错。 如果这个列表越长，或者正确的后缀越往后，就会造成尝试的次数越多，所以resolve .extensions 的配置也会影响到构建的性能 在配置 resolve.extensions时需要遵守 以下几点，以做到尽可能地优化构建性能。 后缀尝试列表要尽可能小，不要将项目中不可能存在的情况写到后缀尝试列表中。 频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程。 在源码中写导入语句时，要尽可能带上后缀 从而可以避免寻找过程。例如在确定的情况下将 require ( ’. /data ’） 写成 require （’. data.json’） 1.6优化module.noParse module.noParse 配置项可 Webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。原因是一些库如 jQuery庞大又没有采用模块化标准，让 Webpack 解析这些文件既耗时又没有意义。 在前面讲解优化 resolve.alias 配置时讲到，单独、完整的 vue.esm.js 文件没有采用模块化，让我们通过配置 module.noParse 忽略对它的递归解析处理，相关的 Webpack 配置如下：12345module.exports = &#123; module: &#123; noParse: [/vue\.runtime\.esm\.js$/] &#125;&#125; 2.使用DllPlugin为web项目接入动态链接库（dll） 1.将网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中 。在一个动态链接库中可以包含多个模块。 2.当需要导入的模块存在于某个动态链接库 中时，这个模块不能被再次打包，而是去动态链接库中获取。 3由于动态链接库中大多数包含的是常用的第 方模块，例如 vue、vue-router ，所以只要不升级这些模块的版本，动态链接库就不用重新编译。 在webpack中，通过以下两个插件实现dll： DllPlugin: 用于打包出一个个单独的动态链接库文件 DllReferencePlugin: 用于在主要的配置文件中引入 DllPlugin 插件打包好的动态链接库文件。 实现过程： 1、动态链接库文件相关的文件需要由 份独立的构建输出，用于为主构建使用。新建webpack.dll.conf.js12345678910111213141516171819202122232425262728293031const path = require('path')const DllPlugin = require('webpack/lib/DllPlugin')function resolve(dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; entry: &#123; vue: ['vue/dist/vue.runtime.esm.js', 'vue-router', 'vuex'], // vant: ['vant'] &#125;, output: &#123; path: resolve('dist'), filename: '[name].dll.js', // 存放动态链接库的全局变量名称，_dll_vue library: '_dll_[name]' &#125;, plugins: [ new DllPlugin(&#123; /* *动态链接库的全局变量名称，需要和 output.library 中的保持一致 *该字段的值也就是输出的 manifest json 文件中 name 字段的值 *例如在 react.manifest json 中就有 ”name“：”_dll_vue" */ name: '_dll_[name]', //描述动态链接库的 manifest json 文件输出时的路径以及文件名称 path: resolve('dist/[name].manifest.json'), context: __dirname &#125;) ]&#125; 2、根据webpack.dll.conf.js构建动态链接库文件及其描述文件。创建build.dll.js123456789101112131415161718192021222324252627282930313233343536373839'use strict'require('./check-versions')()process.env.NODE_ENV = 'production'const ora = require('ora')const rm = require('rimraf')const path = require('path')const chalk = require('chalk')const webpack = require('webpack')const config = require('../config')const webpackConfig = require('./webpack.dll.conf')const spinner = ora('building for dll...')spinner.start()// rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123;// if (err) throw err // &#125;)webpack(webpackConfig, function (err, stats) &#123; spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') if (stats.hasErrors()) &#123; console.log(chalk.red(' Build failed with errors.\n')) process.exit(1) &#125; console.log(chalk.cyan(' Build complete.\n')) &#125;) 这步以后会在dist目录下产生： vue.dll.js vue.manifest.json (描述vue.dll.js中包含哪些模块) 3、修改webpack.prod.conf.js，加入DllReferencePlugin1234567891011const DllReferencePlugin = require('webpack/lib/DllReferencePlugin')//告 Webpack 使用了哪些动态链接库new DllReferencePlugin(&#123;// 描述vue动态链接库的文件内容 manifest: require('../dist/vue.manifest.json'), context: __dirname&#125;),//如果有多个动态链接库文件// new DllReferencePlugin(&#123;// manifest: ...// &#125;), 4、在根目录index.html中引入vue.dll.js12345&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src="./vue.dll.js"&gt;&lt;/script&gt;&lt;/body&gt; 5、npm run build执行构建，可以发现构建速度有了明显的提升 3.Tree Shaking 要让 Tree Shaking 正常工作的前提是，提交给 Webpack JavaScript 代码必须采用了 ES6 的模块化语法。 因为 ES6 模块化语法是静态的（在导入、导出语句中的路径是静态的字符串，而且不能放入其他代码块中），这让 Webpack 可以简单地分析出哪些expo rt 的被 import 了。如果采用了 S5 中的模块化，例如 module.export={ … ｝、require (x+y ）、 if (x) {require （’.／ util ’）｝，则 Webpack 无法分析出可以剔除哪些代码 实现过程: 1. 修改.babelrc1234567&#123;"presets": [ ["env", &#123; "modules": false //关闭 babel 的模块转换功能，保留原本的 ES6语法。 &#125;] ]&#125; 2. 以lodash库为例 往往我们在项目中使用lodash只会用到其提供部分方法，如果我们要tree shaking lodash，应该安装lodash-es而不是lodash，因为lodash库本身是commonjs的模块，不支持tree shaking.同时想要使tree shaking生效，还需要两个插件： babel-plugin-lodash lodash-webpack-plugin 12345// webpack.prod.conf.jsconst LodashModuleReplacementPlugin = require('lodash-webpack-plugin');plugins: [ new LodashModuleReplacementPlugin()] 在import时:12// import _ from 'lodash-es'import &#123; chunk &#125; from 'lodash-es' 这样一来在构建以后lodash就shaking到无影无踪了 2. 以vant组件库为例查看vant的package.json,发现：12"main": "lib/index.js", //commonjs"module": "es/index.js", //esm 在项目中使用大量的第 方库时，我们会发现 Tree Shaking 似乎不生效了，原因是大部分Npm 中的代码都采用了 CommonJS 语法，这导致 Tree shaking 无法正常工作而降级处理。但幸运的是，有些库考虑到了这 点，这些库在发布到 Npm 上时会同时提供两份代码，一份采 CommonJs 模块化语法，一份采用 ES6 模块化语法。并且在 package json 文件中别指出这两份代码的入口。 之前介绍过 mainFields 用于配置采用哪个字段作为模块的入口描述。为了Tree Shaking vant 生效，需要配置 Webpack 的文件寻找规 如下:12345module.exports= &#123; resolve: &#123; mainFields: ['module', 'main', 'browser'] &#125;&#125; 以上配置的含义是优先使用 module 作为入口，如果不存在，就会采用 browser 或者 main 并将其作为入口 社区约定：用 jsnext:main 作为 ES6 模块化代码的入口 要实现按需导入vant组件，需要一个插件：babel-plugin-import，同时修改.babelrc:123456789&#123; "plugins": [ ["import": &#123; "libraryName": "vant", "libraryDirectory": "es", "style": true &#125;] ]&#125; 这样，build后也能够把vant tree shaking 4. 使用 Scope Hoisting scope hoisting减小代码打包后的体积，并且减少函数作用域，减小开销(目前我感觉并没有起作用。。。) new webpack.optimize.ModuleConcatenationPlugin(), 和tree shaking一样，Scope Hoisting 依赖源码时 需采用 S6 模块化语法，还需要配置mainFields 5. 使用compression-webpack-plugin开启gzip 利用该插件生成.gz文件，在服务器开启gzip的情况下，会优先返回.gz文件 以vue-cli为例： 在config/index.js中：123456// Gzip off by default as many popular static hosts such as// Surge or Netlify already gzip all static assets for you.// Before setting to `true`, make sure to:// npm install --save-dev compression-webpack-pluginproductionGzip: true,productionGzipExtensions: ['js', 'css', 'png'], //你想要gzip的文件类型 在webpack.prod.conf.js中已经有这么一段代码：123456789101112131415if (config.build.productionGzip) &#123; const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, //只处理大于此大小(10k)的资产。以byte为单位 默认为0。 minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理 。默认为0.8. &#125;) )&#125; 在build后会生成对应的.gz文件 值得注意的是并不是所有的文件都会生成对应的gzip文件，因为我们设置了threshold: 10240和minRatio: 0.8,文件大小小于10k的不会被gzip，同时只有压缩率比0.8小的资源才会被处理，否则比起直接使用没有gzip的文件，浏览器会花更多的时间用来unzip这些文件，得不偿失 未完待续···]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结一下js里操作数组的方法吧...]]></title>
    <url>%2F2018%2F07%2F05%2Farray%2F</url>
    <content type="text"><![CDATA[数组的栈方法和队列方法123456789101112131415let arr = [1,2,3,4,5];//--栈方法//push(a,b,..,z)方法在数组最后面追加一个或多个元素，返回修改后数组的长度(6)arr.push(6);//此时数组为[1,2,3,4,5,6]//pop()方法，返回并移除数组中的最后一个元素的值(6)arr.pop();//此时数组为[1,2,3,4,5]//--队列方法//shift()方法，返回并移除数组中的第一个元素的值(1)arr.shift();//此时数组为[2,3,4,5]//unshift(a,b,...,z)方法在数组最前面追加一个或多个元素，返回修改后数组的长度(5)arr.unshift(6);//此时数组为[6,2,3,4,5] 重排序方法 reverse() sort() 正是由于reverse()不够灵活，所以出现了sort()，他们均返回重新排序后的数组 操作方法 slice() //不会影响原数组 splice() //可以对数组进行删除、插入、替换，返回从原数组中删除项组成的数组,他会影响原数组 位置方法 indexOf() lastIndexOf() 返回要查找项在数组中的位置，找不到则返回-11234const arr = [1,2,3,4,5,4,3,2,1]arr.indexOf(4) //3arr.lastIndexOf(4) // 5arr.indexOf(0) // -1 数组的迭代器方法不生成新数组的迭代器方法123456789101112131415161718192021222324252627282930313233//1、forEach方法（接收一个函数作为参数）const nums = [1,2,3,4,5];nums.forEach(item =&gt; &#123; console.log(item * item)&#125;);//1，4，9，16，25//2、every方法（接收一个返回值为布尔值的函数，对数组中的每一个元素使用该函数）const evens=[2,4,6,8,10];const isAllEven = evens.every(item =&gt; &#123; return num % 2 === 0;&#125;); //当且仅当数组中的所有的元素返回为真，every函数才会返回为真//3、some方法（只要数组中有一个元素使用方法返回为真，some函数就会返回真） const nums = [1,2,3,5,7,9]; nums.some(item =&gt; &#123; return num % 2 === 0; &#125;); //true //4.reduce方法 //用法一：为数组中的元素求和 function add (currentTotal,currentValue) &#123; return currentTotal+currentValue; &#125; const nums = [1,2,3,4,5]; nums.reduce(add);//15 //用法二：将数组中的元素连接成一个长的字符串 function linkStr (foreStr,currentStr) &#123; return foreStr + currentStr; &#125; const strings = [&quot;xietian&quot;,&quot;is&quot;,&quot;studying&quot;,&quot;javascript&quot;]; strings.reduce(linkStr); 生成新数组的迭代器方法123456789101112131415//1.map方法（类似于不生成新数组中的forEach方法） //取数组中每个单词的第一个字母 const words = [&quot;xietian&quot;,&quot;is&quot;,&quot;studying&quot;,&quot;javascript&quot;]; const firstAlphas = words.map(item =&gt; &#123; return word[0].toUpperCase(); &#125;); firstAlphas.join(&quot;&quot;); //使用join可以去掉连接数组元素的逗号 //2.filter方法（类似于every方法） //筛选出符合条件（即返回值为true）的元素 const nums=[1,2,4,6,8,10]; const evens = nums.filter(item =&gt; &#123; return num % 2 === 0; &#125;); 归并方法 reduce() //从数组的第一项开始遍历 reduceRight() //从数组的最后一项开始遍历 两个方法都会迭代数组的每一项，构建一个最终的返回值 未完待续···]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS简单实现全屏滚动效果]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[原理原理很简单: 通过js设置外层div wrapper(==#wrap==)的高度为浏览器可视区的高度，并设置overflow:hidden; 设置内层div wrapper(==#main==)为position:relative，然后通过滚轮事件改变其top值。 HTML结构首先，HTML结构应该满足下面要求 12345678&lt;div id="wrap"&gt; &lt;div id="main"&gt; &lt;div class="page page1"&gt;1&lt;/div&gt; &lt;div class="page page2"&gt;2&lt;/div&gt; &lt;div class="page page3"&gt;3&lt;/div&gt; &lt;div class="page page4"&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS123456789101112131415161718192021222324#wrap &#123; overflow: hidden;&#125;#main &#123; position: relative; transition: all 1000ms ease;&#125;#page1 &#123; background: #E4E6CE;&#125;#page2 &#123; background: #6CE26C;&#125;#page3 &#123; background: #BF4938;&#125;#page4 &#123; background: #2932E1;&#125; 滚轮事件12345678910111213141516171819202122232425262728293031323334353637383940414243var pages = document.getElementsByClassName("page");var wrap = document.getElementById("wrap");var main = document.getElementById("main");var len = document.documentElement.clientHeight;wrap.style.height = len + "px";for (var i = 0; i &lt; pages.length; i++) &#123; pages[i].style.height = len + "px";&#125; if (navigator.userAgent.toLowerCase().indexOf("firefox") != -1) &#123;//火狐 document.addEventListener("DOMMouseScroll", scrollFun); &#125; else if (document.addEventListener) &#123; document.addEventListener("mousewheel", scrollFun, false); &#125; else if (document.attachEvent) &#123;//IE document.attachEvent("onmousewheel", scrollFun); &#125; else &#123; document.onmousewheel = scrollFun; &#125; var startTime = 0; var endTime = 0; var now = 0; function scrollFun(e) &#123; startTime = new Date().getTime(); var event = e || window.event; var dir = event.detail || -event.wheelDelta; // &gt;0 向下滚动 //1s内只能滚动一屏 if (startTime - endTime &gt; 1000) &#123; console.log(startTime - endTime) if (dir &gt; 0 &amp;&amp; now &gt; -3 * len) &#123; now -= len; main.style.top = now + "px"; endTime = new Date().getTime(); &#125; else if (dir &lt; 0 &amp;&amp; now &lt; 0) &#123; now += len; main.style.top = now + "px"; endTime = new Date().getTime(); &#125; &#125; else &#123; console.log(startTime - endTime) event.preventDefault(); &#125; &#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>fullpage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue服务端渲染]]></title>
    <url>%2F2018%2F05%2F20%2Fvue-ssr%2F</url>
    <content type="text"><![CDATA[前言目前已近用vue全家桶做了几个SPA应用了，但是SPA的缺点很明显：首屏白屏时间较长以及SEO不友好，因此在上述需求下，SSR十分有必要。 注意事项 由于用例和平台 API 的差异，当运行在不同环境中时，我们的代码将不会完全相同 服务器上的数据响应 在纯客户端应用程序(client-only app)中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染(cross-request state pollution)。 因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据(“pre-fetching” data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。禁用响应式数据，还可以避免将「数据」转换为「响应式对象」的性能开销。 组件生命周期钩子函数 由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。 此外还需要注意的是，你应该避免在 beforeCreate 和 created 生命周期时产生全局副作用的代码，例如在其中使用 setInterval 设置 timer。在纯客户端(client-side only)的代码中，我们可以设置一个 timer，然后在 beforeDestroy 或 destroyed 生命周期时将其销毁。但是，由于在 SSR 期间并不会调用销毁钩子函数，所以 timer 将永远保留下来。为了避免这种情况，请将副作用代码移动到 beforeMount 或 mounted 生命周期中。 访问特定平台(Platform-Specific) API 通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 window 或 document，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。 对于共享于服务器和客户端，但用于不同平台 API 的任务(task)，建议将平台特定实现包含在通用 API 中，或者使用为你执行此操作的 library。例如，axios 是一个 HTTP 客户端，可以向服务器和客户端都暴露相同的 API。 对于仅浏览器可用的 API，通常方式是，在「纯客户端(client-only)」的生命周期钩子函数中惰性访问(lazily access)它们。 自定义指令大多数自定义指令直接操作DOM，因此会在服务器端渲染(SSR)过程中导致错误。有两种方法可以解决这个问题： 推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。 如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 directives 选项所提供”服务器端版本(server-side version)”。 Let’s get it搭建脚手架12// 利用webpack-simple搭建一个简单的脚手架vue init webpack-simple vue-ssr src目录可能需要像下面这样： 12345678910src├── components│ ├── Foo.vue│ ├── Bar.vue│ └── Baz.vue├── index.template.html # SSR模板├── App.vue├── app.js # 通用 entry(universal entry)├── entry-client.js # 仅运行于浏览器└── entry-server.js # 仅运行于服务器 客户端与服务端通用入口：app.js123456789101112import Vue from 'vue'import App from './App.vue'// 导出一个工厂函数，用于创建新的// 应用程序、router 和 store 实例export function createApp () &#123; const app = new Vue(&#123; // 根实例简单的渲染应用程序组件。 render: h =&gt; h(App) &#125;) return &#123; app &#125;&#125; 客户端入口：entry-client.js 客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中 1234567import &#123; createApp &#125; from './app'const &#123; app &#125; = createApp()// 这里假定 App.vue 模板中根元素具有 `id="app"`app.$mount('#app') 服务端入口：entry-server.js 服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配(server-side route matching)和数据预取逻辑(data pre-fetching logic) 123456import &#123; createApp &#125; from './app'export default context =&gt; &#123; const &#123; app &#125; = createApp() return app&#125; 构建配置（webpack）建议将配置分为三个文件： webpack.base.config.js: 包含在两个环境共享的配置，例如，输出路径(output path)，别名(alias)和 loader。 webpack.client.config.js webpack.server.config.js webpack.client.config.js和webpack.server.config.js，可以通过使用 webpack-merge 来简单地扩展webpack.base.config.js webpack.base.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106var path = require('path')var webpack = require('webpack')module.exports = &#123; output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: '/dist/' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'vue-style-loader', 'css-loader' ], &#125;, &#123; test: /\.scss$/, use: [ 'vue-style-loader', 'css-loader', 'sass-loader' ], &#125;, &#123; test: /\.sass$/, use: [ 'vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax' ], &#125;, &#123; test: /\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; // Since sass-loader (weirdly) has SCSS as its default parse mode, we map // the "scss" and "sass" values for the lang attribute to the right configs here. // other preprocessors should work out of the box, no loader config like this necessary. 'scss': [ 'vue-style-loader', 'css-loader', 'sass-loader' ], 'sass': [ 'vue-style-loader', 'css-loader', 'sass-loader?indentedSyntax' ] &#125; // other vue-loader options go here &#125; &#125;, &#123; test: /\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg)$/, loader: 'file-loader', options: &#123; name: '[name].[ext]?[hash]' &#125; &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' &#125;, extensions: ['*', '.js', '.vue', '.json'] &#125;, devServer: &#123; historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, devtool: '#eval-source-map'&#125;if (process.env.NODE_ENV === 'production') &#123; module.exports.devtool = '#source-map' // http://vue-loader.vuejs.org/en/workflow/production.html module.exports.plugins = (module.exports.plugins || []).concat([ new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; sourceMap: true, compress: &#123; warnings: false &#125; &#125;), new webpack.LoaderOptionsPlugin(&#123; minimize: true &#125;) ])&#125; webpack.client.config.js 如果你使用 CommonsChunkPlugin(webpack4使用splitChunkPlugin)，请确保仅在客户端配置(client config)中使用，因为服务器包需要单独的入口 chunk1234567891011121314151617181920212223const webpack = require('webpack')const merge = require('webpack-merge')const baseConfig = require('./webpack.base.config.js')const VueSSRClientPlugin = require('vue-server-renderer/client-plugin')module.exports = merge(baseConfig, &#123; entry: './src/entry-client.js', output: &#123; filename: '[name].client.js' &#125;, plugins: [ // 重要信息：这将 webpack 运行时分离到一个引导 chunk 中， // 以便可以在之后正确注入异步 chunk。 // 这也为你的 应用程序/vendor 代码提供了更好的缓存。 new webpack.optimize.CommonsChunkPlugin(&#123; name: "manifest", minChunks: Infinity &#125;), // 此插件在输出目录中 // 生成 `vue-ssr-client-manifest.json`。 // new VueSSRClientPlugin() ]&#125;) webpack.client.config.js12345678910111213141516171819202122232425262728293031323334353637383940const merge = require('webpack-merge')const nodeExternals = require('webpack-node-externals')const baseConfig = require('./webpack.base.config.js')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')module.exports = merge(baseConfig, &#123; // 将 entry 指向应用程序的 server entry 文件 entry: '/path/to/entry-server.js', // 这允许 webpack 以 Node 适用方式(Node-appropriate fashion)处理动态导入(dynamic import)， // 并且还会在编译 Vue 组件时， // 告知 `vue-loader` 输送面向服务器代码(server-oriented code)。 target: 'node', // 对 bundle renderer 提供 source map 支持 devtool: 'source-map', // 此处告知 server bundle 使用 Node 风格导出模块(Node-style exports) output: &#123; libraryTarget: 'commonjs2' &#125;, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应用程序依赖模块。可以使服务器构建速度更快， // 并生成较小的 bundle 文件。 externals: nodeExternals(&#123; // 不要外置化 webpack 需要处理的依赖模块。 // 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件， // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单 whitelist: /\.css$/ &#125;), // 这是将服务器的整个输出 // 构建为单个 JSON 文件的插件。 // 默认文件名为 `vue-ssr-server-bundle.json` plugins: [ // new VueSSRServerPlugin() ]&#125;) 打包1.执行以下命令：12//生成客户端打包文件webpack --config ./build/webpack.client.config.js 会在dist目录下生成： main.client.js manifest.client.js 2.执行以下命令：12//生成服务端打包文件webpack --config ./build/webpack.server.config.js 会在dist目录下生成： main.server.js 修改server.js12345678910111213141516171819202122232425262728293031323334353637383940const Vue = require('vue')const express = require('express')const server = express()const renderer = require('vue-server-renderer').createRenderer(&#123; template: require('fs').readFileSync('./src/index.template.html', 'utf-8')&#125;)// const createApp = require('./src/app.js')// 通过服务端打包文件main.server.js来创建app实例const createApp = require('./dist/main.server.js').default// 将dist文件夹作为静态资源目录server.use('/dist', express.static('./dist'))server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', meta: ` &lt;meta charset="utf-8"&gt; `, url: req.url &#125; // const app = new Vue(&#123; // data: &#123; // url: req.url // &#125;, // template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;` // &#125;) // 不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例 const app = createApp(context) renderer.renderToString(app, context).then(html =&gt; &#123; res.end(html) &#125;).catch(e =&gt; &#123; res.status(500).end('Internal Server Error') &#125;)&#125;)server.listen(8081) index.template.html中引入client端打包文件123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt; &#123;&#123;&#123;meta&#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;script src="/dist/manifest.client.js"&gt;&lt;/script&gt; &lt;script src="/dist/main.client.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行以下命令：12node server# supervisor server 就可以成功访问到vue欢迎页面了 路由和代码分割在src目录下创建router.js1234567891011121314151617import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)export function createRouter () &#123; return new Router(&#123; mode: 'history', routes: [ &#123; path: '/hello/:id', // 动态导入组件，需要安装babel-preset-stage-2 component: () =&gt; import('./components/hello') &#125; ] &#125;)&#125; 修改通用入口app.js1234567891011121314151617import Vue from 'vue'import App from './App.vue'import &#123;createRouter&#125; from './router'// 导出一个工厂函数，用于创建新的// 应用程序、router 和 store 实例export function createApp () &#123; const app = new Vue(&#123; // 根实例简单的渲染应用程序组件。 render: h =&gt; h(App), router &#125;) const router = createRouter() return &#123; app, router &#125;&#125; 修改entry-client.js12345//挂载 app 之前调用 router.onReady//因为路由器必须要提前解析路由配置中的异步组件，才能正确地调用组件中可能存在的路由钩子router.onReady(() =&gt; &#123; app.$mount('#app')&#125;) 在 entry-server.js 中实现服务器端路由逻辑123456789101112131415161718192021222324import &#123; createApp &#125; from './app'export default context =&gt; &#123; // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise， // 以便服务器能够等待所有的内容在渲染前就已经准备就绪。 return new Promise((resolve, reject) =&gt; &#123; const &#123; app, router &#125; = createApp() // 设置服务器端 router 的位置 router.push(context.url) // 等到 router 将可能的异步组件和钩子函数解析完 router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents() // 匹配不到的路由，执行 reject 函数，并返回 404 if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;) &#125; // Promise 应该 resolve 应用程序实例，以便它可以渲染 resolve(app) &#125;, reject) &#125;)&#125; 修改server.js12345678910111213141516171819202122232425262728293031server.get('*', (req, res) =&gt; &#123; const context = &#123; title: 'hello', meta: ` &lt;meta charset="utf-8"&gt; `, url: req.url &#125; // const app = createApp(context) // renderer.renderToString(app, context).then(html =&gt; &#123; // res.end(html) // &#125;).catch(e =&gt; &#123; // res.status(500).end('Internal Server Error') // &#125;) createApp(context).then(app =&gt; &#123; renderer.renderToString(app, (err, html) =&gt; &#123; if (err) &#123; if (err.code === 404) &#123; res.status(404).end('Page not found') &#125; else &#123; res.status(500).end('Internal Server Error') &#125; &#125; else &#123; res.end(html) &#125; &#125;) &#125;)&#125;) 再次打包1.执行以下命令：12//生成客户端打包文件webpack --config ./build/webpack.client.config.js 会在dist目录下生成： 0.client.js main.client.js manifest.client.js 2.执行以下命令：12//生成服务端打包文件webpack --config ./build/webpack.server.config.js 会在dist目录下生成： 0.server.js main.server.js 上面的0.client.js和0.server.js就是动态加载的组件hello.vue所打包出来的文件，这样就可以按需引用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F04%2F22%2Fjs-sort%2F</url>
    <content type="text"><![CDATA[一、前言本文整理了几种js排序方法 sort() 快速排序 冒泡排序 二、sort()利用sort function 可以完成一些简单的数组排序 对数组排序1234567var arr = [3,55,7];arr.sort();arr.sort(function(a,b) &#123; return a - b;&#125;);console.log(arr);//输出结果[3,7,55] 根据数组对象的某一属性排序123456789101112131415var arr= [ &#123; 'rank': 2&#125;, &#123; 'rank': 1&#125;, &#123; 'rank': 5&#125;, &#123; 'rank': 6&#125;];arr.sort(function(a, b) &#123; return a.rank - b.rank;&#125;);console.log(arr);//输出结果&#123; 'rank': 1&#125;,&#123; 'rank': 2&#125;,&#123; 'rank': 5&#125;,&#123; 'rank': 6&#125; 三、快速排序1234567891011121314151617function quickSort(arr) &#123; let len = arr.length if(len &lt;= 1) &#123; return arr &#125; let i = Math.floor(len / 2) let num = arr.splice(i, 1) let left = [], right = [] for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; num) &#123; left.push(arr[i]) &#125;else &#123; right.push(arr[i]) &#125; &#125; return quickSort(left).concat(num, quickSort(right))&#125;console.log(quickSort([1,11,2,2,6]))//[1,2,2,6,11] 可以看出，虽然排序是正确的，但是无法取出重复元素2，要实现去重的话用ES6的Set数据结构可以方便的做到： 1234const arr = [1,11,2,2,6]const newArr = [...new Set(arr)]//or//const newArr = Array.from(new Set(arr)) 四、冒泡排序 利用双层循环来逐个比较数组的每个值 12345678910111213141516171819function bubbleSort(arr) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for(let j = i + 1; j &lt; arr.length; j++) &#123; //let n = 0 //if(arr[i] &gt; arr[j]) &#123; //n = arr[i] //arr[i] = arr[j] //arr[j] = n //&#125; //有了ES6的结构赋值，交换数值只要一句话 if(arr[i] &gt; arr[j]) &#123; [arr[i], arr[j]] = [arr[j], arr[i]] &#125; &#125; &#125; return arr&#125;console.log(bubbleSort([1,11,2,7]))//[1,2,7,11]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx反向代理]]></title>
    <url>%2F2018%2F03%2F22%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、前言准备在上面部署一个简单的node应用。 二、创建一个node服务 创建一个app.js文件： 1touch app.js 用vim打开： 1vim app.js 创建啥都没有的服务，看下效果： 1234567var http = require('http')http.createServer(function(req,res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;) res.end('first node app')&#125;).listen(80)console.log('your server is running at http://120.79.143.53:8080/') 保存退出，执行： 1node app.js 发现80端口冲突，因此需要修改端口号 将上面对的端口号改成8081后执行node app.js后服务跑了起来，但是打开浏览器依然无法访问，那应该就是防火墙未开通8081的端口号 我装的是CENTOS7.3，它使用firewall来代替iptables，执行以下命令查看防火墙开放的端口号： 1firewall-cmd --list-ports 显示：80/tcp，显然防火墙只开放了80端口 执行以下命令来开发新端口：1firewall-cmd --zone=public(作用域) --add-port=8081/tcp(端口和访问类型) --permanent(永久生效) 然后重启防火墙：1firewall-cmd --reload 执行node app开启node服务，打开浏览器访问120.79.143.53发现还是不行，不过试了下可以看到输出信息first node：1curl 127.0.0.1:8081 这就很费解了，查了好多资料都没找到解决办法，只能先放着了 然后今天上SF咨询这个问题，因为我买的阿里云ECS，++需要重新配置一下安全组的规则++。 三、小结一下只有在安全组配置了端口范围才算是真正的开放了防火墙端口，单单使用firewall-cmd --zone=public --add-port=8081/tcp --permanent是不行的。 四、PM2PM2用来提供一个持久的node服务，即使关闭终端后也能正常提供服务 安装： 1npm install pm2 -g 开启： 1pm2 start app.js （--watch） 其它命令： pm2 list用于查看开启的node服务列表 pm2 show NAME用于查看某个node服务详情 pm2 stop/start ID/NAME用于开启停止node服务 具体查看pm2官网：http://pm2.keymetrics.io/ 五、Nginx实现反向代理上面，一个简单的node服务跑在了服务器的8081端口，但是，我需要通过直接访问120.79.143.xx来访问这个node服务的话，就需要用到nginx了 原理： 通过配置nginx代理来将来自80端口的请求转发到8081端口 好了，下面就开始写配置文件了： 1. 进入nginx配置文件夹，查看下面的配置文件 123cd /etc/nginxls 2. 创建conf.d文件夹，创建一个配置文件 123mkdir conf.dvim conf.d/firstnode-8081.conf 3. firstnode-8081.conf 12345678910111213141516171819# 注意tian0o0这个命名，自己随意取，但是上下要一致upstream tian0o0 &#123; server 127.0.0.1:8081;&#125;server &#123; listen 80; server_name 120.79.143.xx; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://tian0o0; proxy_redirect off; &#125;&#125; 4. 保存退出，查看配置文件是否有错： 1nginx -t 5. 重启nginx服务： 1/bin/systemctl restart nginx.service 6. 直接访问120.79.143.xx就可以访问服务器上8081端口的服务了。这就是nginx反向代理的简单实现。 六、域名解析虽然是在万网上面买的域名，阿里云也提供了域名解析服务，不过我还是把它拿到了DNSPod上进行处理，以后如果买了其它域名服务商的域名都可以在DNSPod进行统一管理。 这时我的域名www.tian0o0.top的首页还是nginx的启动页面，需要将其与服务器ip对应起来的话就要修改nginx的配置，将来自www.tian0o0.top的请求转发到服务器上的其它端口，步骤和上面类似，**需要注意防火墙是否开放了我所需要的端口** 修改firstnode-8081.conf：123456789101112131415161718upstream firstnode &#123; server 127.0.0.1:8081;&#125;server &#123; listen 80; server_name www.tian0o0.top; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://firstnode; proxy_redirect off; &#125;&#125; 这样访问www.tian0o0.top就能够通过nginx将请求映射到服务器的8081端口，访问到我的node服务 七、安装mongodb 创建仓库文件 1vim /etc/yum.repos.d/mongodb-org-3.4.repo 然后复制下面配置,保存退出 123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc yum安装 1yum install -y mongodb-org 这一步耗时比较久，安装好后修改mongod.conf 1vim /etc/mongod.conf 修改配置文件的 bindIp, 默认是 127.0.0.1 只限于本机连接。所以安装完成后必须把这个修改为 0.0.0.0 ,否则通过别的机器是没法连接的 启动、停止mongodb 123service mongod startservice mongod stop 通过查看日志看mongodb是否启动成功： 1cat /var/log/mongodb/mongod.log 如果出现下面信息说明启动成功（27017是mongodb的默认端口）： 1[initandlisten] waiting for connections on port 27017]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做一个自定义滚动条]]></title>
    <url>%2F2018%2F03%2F17%2Fv-custom%2F</url>
    <content type="text"><![CDATA[一、前言最近在做的项目需要用到自定义滚动条，既然时间充裕，就自己做了个。由于使用Vue在做开发，因此考虑到可复用性的问题，将其做成了Vue的全局自定义指令，只要满足对应的HTML结构就可以在任意地方调用，相对来说也是很方便的。 二、原理（以下默认内容高度超出容器高度。） 2.1 结构需要满足以下HTML结构： 12345678910&lt;div class="wrapper"&gt; &lt;div class="content-wrapper" v-mousewheel&gt; &lt;div class="content"&gt; &lt;!--滚动内容--&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="scroll-bar"&gt; &lt;div class="scroll-block" v-scrollY&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.2原理 通过拖拽事件和滚轮事件动态改变内容区域的top值 因此需要: 设置容器content-wrapper属性：overflow: hidden; 设置内容content属性：position: absolute; 这样，基础工作就已经ok了，开始写交互事件。 三、代码3.1 拖拽事件大的方向上没什么问题，但是需要注意的是，拖动滑块时如果不做处理，会出现抖动现象，这是因为拖动时onmousemove事件频繁触发导致，因此加入防抖功能即可： 加个定时器，每次执行onmousemove时清除定时器防止多次触发，定时器事件设置为20ms是因为浏览器的最大刷新频率为16.7ms/次。 这样，在滑块scroll-block上加一个自定义指令v-scrollY,就可以实现拖拽效果啦~ 12345678910111213141516171819202122232425262728Vue.directive('scrollY', &#123; bind (el, binding) &#123; let $el = el $el.onmousedown = function(e) &#123; let disY = e.clientY - $el.offsetTop let $content = $el.parentNode.parentNode.firstChild let contentH = $content.clientHeight document.onmousemove = function(e) &#123; clearTimeout(timer) let timer = setTimeout(() =&gt; &#123; // 滚动滑块滚动距离 let top = Math.min(Math.max(e.clientY - disY, 0), 306) // 内容区域滚动距离 let topC = top * (contentH - 600) / 306 $el.style.top = top + 'px' $content.style.top = -topC +'px' &#125;, 20) $el.style.backgroundColor = '#acaaaa' &#125; document.onmouseup = function(e) &#123; document.onmousemove = null document.onmouseup =null $el.style.backgroundColor = '#e9e9e9' &#125; &#125; &#125;&#125;) 3.2 滚轮事件滚轮事件相对来说比较麻烦，这是因为：firefox和其他浏览器的滚轮事件不一样。 在firefox中是DOMMouseScroll ,其他浏览器中则是mousewheel 在firefox中通过e.detail的正负值来判断上下滚动，其他浏览器中则是通过e.wheelDetla来判断上下滚动 - firefox 其它浏览器 上滚 e.detail &lt; 0 e.wheelDetla &gt; 0 下滚 e.detail &gt; 0 e.wheelDetla &lt; 0 其它有几点值得说一下： 滚动时需要阻值默认事件，防止在子滚动区滚动时使父滚动区跟着滚动； 滚动区内容设置：user-select: none;因为我发现在拖拽的时候鼠标离开滚动滑块会选中滚动内容区文字。 注意上面几点应该就没问题了，然后在容器content-wrapper上添加v-mousewheel就可以滚动啦～123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.directive('mousewheel', &#123; bind( el, biding ) &#123; let num = 0 let $el = el function addEvent(obj, type, fn, capture) &#123; if (obj.addEventListener) &#123; if( !capture ) &#123;capture = false&#125; obj.addEventListener(type, fn, capture) &#125; else if (obj.attachEvent) &#123; obj.attachEvent("on" + type, fn) &#125; &#125; function scrollDown() &#123; let $block = $el.parentNode.children[1].children[0] let dis = Math.min(20 * (num--), $el.clientHeight - 600) $el.style.top = Math.min(0, -dis) + 'px' let topB = Math.max(0, dis) * 306 / ($el.clientHeight - 600) $block.style.top = topB + 'px' &#125; function scrollUp() &#123; let $block = $el.parentNode.children[1].children[0] let dis = Math.min(20 * (num++), $el.clientHeight - 600) $el.style.top = Math.min(0, -dis) + 'px' let topB = Math.min(0, -dis) * 306 / ($el.clientHeight - 600) $block.style.top = -topB + 'px' &#125; function customScroll(e) &#123; if( e.wheelDelta ) &#123; if (e.wheelDelta &gt; 0) &#123; //下滚 scrollDown() &#125; else &#123; //上滚 scrollUp() &#125; &#125;else if ( e.detail ) &#123; //兼容火狐 if (e.detail &lt; 0) &#123; //下滚 scrollDown() &#125; else &#123; //上滚 scrollUp() &#125; &#125; &#125; addEvent($el, 'mousewheel', (e) =&gt; &#123; let ev = e || window.event ev.preventDefault ? ev.preventDefault() : ev.returnvalue = false customScroll(e) &#125;) // 兼容firefox addEvent($el, 'DOMMouseScroll', (e) =&gt; &#123; let ev = e || window.event ev.preventDefault ? ev.preventDefault() : ev.returnvalue = false customScroll(e) &#125;) &#125;&#125;) 四、小结考虑到滚轮事件在不同浏览器中的表现不同，处理好兼容性的问题是至关重要的。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>自定义滚动条</tag>
        <tag>自定义指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise之不完全解读]]></title>
    <url>%2F2018%2F03%2F07%2Fpromise%2F</url>
    <content type="text"><![CDATA[一、前言1.什么是promise？ 2.promise有什么用？ 3.什么时候用promise？ MDN的官方解释是： Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值 新学一个新的概念的时候光从字面上其实无法很好的理解其含义，总之让我们带着这三个问题，一步步抽丝剥茧，道出它的真面目 所谓promise，翻译成中文就是：许诺、承诺的意思，表示一种将来的状态。 它在异步计算中扮演者重要的角色：它可以将异步操作队列化，按照我们想要的顺序进行执行，并且返回符合预期的结果 我们可以在对象之间传递和操作promise，帮助我们处理队列 二、历史如果了解JavaScript的历史，可能会帮助我们更好的认识promise。 为检查表单而生的JavaScript 在JavaScript出现以前，用户在填写表单时稍有不慎就得重新填写一遍，毫无用户体验。这时就出现了JavaScript，他天生就是用来检查表单的。那么作为一门浏览器端的语言，就注定了它异步的命运：它的执行不能使页面冻结。 其实在JavaScript里面异步的问题还不是特别严重，因为JavaScript里的异步主要以DOM操作为主，但是自从出现了Nodejs以后，它对异步的依赖进一步加剧。 三、promise的基本概念使用promise的基本方法：12345678910111213new Promise( (resolve, reject) =&gt; &#123; resolve() //or reject()&#125; ).then(//可以返回一个新的promise对象//可以返回一个同步的值//可以抛出一个同步的异常).catch(//捕获错误) promise有三种状态： pending：进行中 fulfilled：成功 rejected：失败 而且一旦其状态变为fulfill或reject，就不可继续改变状态 promise通过引入仅仅一个回调函数来避免所谓的回调地狱，也就是说，在.then()里面不应该出现新的回调。正确的做法是：返回一个新的promise对象来实现.then()的链式调用。 四、promise陷阱（promise穿透）纸上得来终觉浅，直接上代码吧： 1234567891011121314151617181920212223//在promise里面不返回任何值或者返回false，会有什么结果？console.log('1');new Promise(resolve =&gt; &#123; setTimeout( () =&gt; &#123; resolve('2'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log(value); console.log('3'); (function () &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log('4'); resolve('5'); &#125;, 2000); &#125;); &#125;()); return false; &#125;) .then( value =&gt; &#123; console.log(value + '6'); &#125;); 执行顺序：1-2-3-false6-4 解释：在promise里面不返回任何值或者返回false，他会立刻往下执行。同理，如果去掉return false,结果就是 1-2-3-undefined6-4 （注意：那个立即执行函数由于不再.then()的直接回调里面，因此它与.then()的回调不处于同一执行栈） 写出简洁的promise 1234new Promise( (resolve, reject) =&gt; &#123; resolve(something)&#125;).then(/*```*/) 其实写成下面这种方式更加好看 1Promise.resolve(something).then(/*```*/) 那么，我们再来看一个例子： 12345Promise.resolve('foo').then(Promise.resolve('bar')).then((res) =&gt; &#123; consoe.log(res) // foo&#125;) 结果居然不是‘bar’而是‘foo’，实际上这和前面的例子很相似，如果给.then()传递的不是一个函数，它回直接解析为.then(null)，导致立即执行下一个.then(),发生所谓的promise穿透 如果想要得到‘bar’,可以这么写： 1234567Promise.resolve('foo').then( () =&gt; &#123; return Promise.resolve('bar')&#125;).then( (res) =&gt; &#123; consoe.log(res) // bar&#125;) 最后，推荐这篇文章：we have a problem with promises]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一篇博客]]></title>
    <url>%2F2018%2F03%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[介绍这是用GitHub Pages + Hexo搭建的博客。 目的目的很简单，希望能够记录下工作上遇到的难题，以及我是通过怎样的途径解决的，避免以后犯相同的错误；同时，如果这个博客能够帮助到他人，也将是我的荣幸。 联系方式xietian19941007@gmail.com]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
